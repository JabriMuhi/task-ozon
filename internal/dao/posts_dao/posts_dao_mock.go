// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package posts_dao

//go:generate minimock -i taskOzon/internal/dao/posts_dao.PostCRUD -o posts_dao_mock.go -n PostCRUDMock -p posts_dao

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"taskOzon/graph/model"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PostCRUDMock implements PostCRUD
type PostCRUDMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPost          func(ctx context.Context, title string, content string, authorID int, commentsAllowed bool) (i1 int, err error)
	inspectFuncAddPost   func(ctx context.Context, title string, content string, authorID int, commentsAllowed bool)
	afterAddPostCounter  uint64
	beforeAddPostCounter uint64
	AddPostMock          mPostCRUDMockAddPost

	funcChangeCommentsAllowed          func(ctx context.Context, postID int, commentsAllowed bool) (i1 int, err error)
	inspectFuncChangeCommentsAllowed   func(ctx context.Context, postID int, commentsAllowed bool)
	afterChangeCommentsAllowedCounter  uint64
	beforeChangeCommentsAllowedCounter uint64
	ChangeCommentsAllowedMock          mPostCRUDMockChangeCommentsAllowed

	funcDeletePost          func(ctx context.Context, postID int) (i1 int, err error)
	inspectFuncDeletePost   func(ctx context.Context, postID int)
	afterDeletePostCounter  uint64
	beforeDeletePostCounter uint64
	DeletePostMock          mPostCRUDMockDeletePost

	funcGetPost          func(ctx context.Context, postID int) (pp1 *model.Post, err error)
	inspectFuncGetPost   func(ctx context.Context, postID int)
	afterGetPostCounter  uint64
	beforeGetPostCounter uint64
	GetPostMock          mPostCRUDMockGetPost

	funcGetPosts          func(ctx context.Context, page int, itemsByPage int) (ppa1 []*model.Post, err error)
	inspectFuncGetPosts   func(ctx context.Context, page int, itemsByPage int)
	afterGetPostsCounter  uint64
	beforeGetPostsCounter uint64
	GetPostsMock          mPostCRUDMockGetPosts
}

// NewPostCRUDMock returns a mock for PostCRUD
func NewPostCRUDMock(t minimock.Tester) *PostCRUDMock {
	m := &PostCRUDMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPostMock = mPostCRUDMockAddPost{mock: m}
	m.AddPostMock.callArgs = []*PostCRUDMockAddPostParams{}

	m.ChangeCommentsAllowedMock = mPostCRUDMockChangeCommentsAllowed{mock: m}
	m.ChangeCommentsAllowedMock.callArgs = []*PostCRUDMockChangeCommentsAllowedParams{}

	m.DeletePostMock = mPostCRUDMockDeletePost{mock: m}
	m.DeletePostMock.callArgs = []*PostCRUDMockDeletePostParams{}

	m.GetPostMock = mPostCRUDMockGetPost{mock: m}
	m.GetPostMock.callArgs = []*PostCRUDMockGetPostParams{}

	m.GetPostsMock = mPostCRUDMockGetPosts{mock: m}
	m.GetPostsMock.callArgs = []*PostCRUDMockGetPostsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostCRUDMockAddPost struct {
	optional           bool
	mock               *PostCRUDMock
	defaultExpectation *PostCRUDMockAddPostExpectation
	expectations       []*PostCRUDMockAddPostExpectation

	callArgs []*PostCRUDMockAddPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PostCRUDMockAddPostExpectation specifies expectation struct of the PostCRUD.AddPost
type PostCRUDMockAddPostExpectation struct {
	mock      *PostCRUDMock
	params    *PostCRUDMockAddPostParams
	paramPtrs *PostCRUDMockAddPostParamPtrs
	results   *PostCRUDMockAddPostResults
	Counter   uint64
}

// PostCRUDMockAddPostParams contains parameters of the PostCRUD.AddPost
type PostCRUDMockAddPostParams struct {
	ctx             context.Context
	title           string
	content         string
	authorID        int
	commentsAllowed bool
}

// PostCRUDMockAddPostParamPtrs contains pointers to parameters of the PostCRUD.AddPost
type PostCRUDMockAddPostParamPtrs struct {
	ctx             *context.Context
	title           *string
	content         *string
	authorID        *int
	commentsAllowed *bool
}

// PostCRUDMockAddPostResults contains results of the PostCRUD.AddPost
type PostCRUDMockAddPostResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPost *mPostCRUDMockAddPost) Optional() *mPostCRUDMockAddPost {
	mmAddPost.optional = true
	return mmAddPost
}

// Expect sets up expected params for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) Expect(ctx context.Context, title string, content string, authorID int, commentsAllowed bool) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.paramPtrs != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by ExpectParams functions")
	}

	mmAddPost.defaultExpectation.params = &PostCRUDMockAddPostParams{ctx, title, content, authorID, commentsAllowed}
	for _, e := range mmAddPost.expectations {
		if minimock.Equal(e.params, mmAddPost.defaultExpectation.params) {
			mmAddPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPost.defaultExpectation.params)
		}
	}

	return mmAddPost
}

// ExpectCtxParam1 sets up expected param ctx for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) ExpectCtxParam1(ctx context.Context) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostCRUDMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddPost
}

// ExpectTitleParam2 sets up expected param title for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) ExpectTitleParam2(title string) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostCRUDMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.title = &title

	return mmAddPost
}

// ExpectContentParam3 sets up expected param content for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) ExpectContentParam3(content string) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostCRUDMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.content = &content

	return mmAddPost
}

// ExpectAuthorIDParam4 sets up expected param authorID for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) ExpectAuthorIDParam4(authorID int) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostCRUDMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.authorID = &authorID

	return mmAddPost
}

// ExpectCommentsAllowedParam5 sets up expected param commentsAllowed for PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) ExpectCommentsAllowedParam5(commentsAllowed bool) *mPostCRUDMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostCRUDMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.commentsAllowed = &commentsAllowed

	return mmAddPost
}

// Inspect accepts an inspector function that has same arguments as the PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) Inspect(f func(ctx context.Context, title string, content string, authorID int, commentsAllowed bool)) *mPostCRUDMockAddPost {
	if mmAddPost.mock.inspectFuncAddPost != nil {
		mmAddPost.mock.t.Fatalf("Inspect function is already set for PostCRUDMock.AddPost")
	}

	mmAddPost.mock.inspectFuncAddPost = f

	return mmAddPost
}

// Return sets up results that will be returned by PostCRUD.AddPost
func (mmAddPost *mPostCRUDMockAddPost) Return(i1 int, err error) *PostCRUDMock {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostCRUDMockAddPostExpectation{mock: mmAddPost.mock}
	}
	mmAddPost.defaultExpectation.results = &PostCRUDMockAddPostResults{i1, err}
	return mmAddPost.mock
}

// Set uses given function f to mock the PostCRUD.AddPost method
func (mmAddPost *mPostCRUDMockAddPost) Set(f func(ctx context.Context, title string, content string, authorID int, commentsAllowed bool) (i1 int, err error)) *PostCRUDMock {
	if mmAddPost.defaultExpectation != nil {
		mmAddPost.mock.t.Fatalf("Default expectation is already set for the PostCRUD.AddPost method")
	}

	if len(mmAddPost.expectations) > 0 {
		mmAddPost.mock.t.Fatalf("Some expectations are already set for the PostCRUD.AddPost method")
	}

	mmAddPost.mock.funcAddPost = f
	return mmAddPost.mock
}

// When sets expectation for the PostCRUD.AddPost which will trigger the result defined by the following
// Then helper
func (mmAddPost *mPostCRUDMockAddPost) When(ctx context.Context, title string, content string, authorID int, commentsAllowed bool) *PostCRUDMockAddPostExpectation {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostCRUDMock.AddPost mock is already set by Set")
	}

	expectation := &PostCRUDMockAddPostExpectation{
		mock:   mmAddPost.mock,
		params: &PostCRUDMockAddPostParams{ctx, title, content, authorID, commentsAllowed},
	}
	mmAddPost.expectations = append(mmAddPost.expectations, expectation)
	return expectation
}

// Then sets up PostCRUD.AddPost return parameters for the expectation previously defined by the When method
func (e *PostCRUDMockAddPostExpectation) Then(i1 int, err error) *PostCRUDMock {
	e.results = &PostCRUDMockAddPostResults{i1, err}
	return e.mock
}

// Times sets number of times PostCRUD.AddPost should be invoked
func (mmAddPost *mPostCRUDMockAddPost) Times(n uint64) *mPostCRUDMockAddPost {
	if n == 0 {
		mmAddPost.mock.t.Fatalf("Times of PostCRUDMock.AddPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPost.expectedInvocations, n)
	return mmAddPost
}

func (mmAddPost *mPostCRUDMockAddPost) invocationsDone() bool {
	if len(mmAddPost.expectations) == 0 && mmAddPost.defaultExpectation == nil && mmAddPost.mock.funcAddPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPost.mock.afterAddPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPost implements PostCRUD
func (mmAddPost *PostCRUDMock) AddPost(ctx context.Context, title string, content string, authorID int, commentsAllowed bool) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAddPost.beforeAddPostCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPost.afterAddPostCounter, 1)

	if mmAddPost.inspectFuncAddPost != nil {
		mmAddPost.inspectFuncAddPost(ctx, title, content, authorID, commentsAllowed)
	}

	mm_params := PostCRUDMockAddPostParams{ctx, title, content, authorID, commentsAllowed}

	// Record call args
	mmAddPost.AddPostMock.mutex.Lock()
	mmAddPost.AddPostMock.callArgs = append(mmAddPost.AddPostMock.callArgs, &mm_params)
	mmAddPost.AddPostMock.mutex.Unlock()

	for _, e := range mmAddPost.AddPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddPost.AddPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPost.AddPostMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPost.AddPostMock.defaultExpectation.params
		mm_want_ptrs := mmAddPost.AddPostMock.defaultExpectation.paramPtrs

		mm_got := PostCRUDMockAddPostParams{ctx, title, content, authorID, commentsAllowed}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameter title, want: %#v, got: %#v%s\n", *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameter content, want: %#v, got: %#v%s\n", *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.authorID != nil && !minimock.Equal(*mm_want_ptrs.authorID, mm_got.authorID) {
				mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameter authorID, want: %#v, got: %#v%s\n", *mm_want_ptrs.authorID, mm_got.authorID, minimock.Diff(*mm_want_ptrs.authorID, mm_got.authorID))
			}

			if mm_want_ptrs.commentsAllowed != nil && !minimock.Equal(*mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed) {
				mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameter commentsAllowed, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed, minimock.Diff(*mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPost.t.Errorf("PostCRUDMock.AddPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPost.AddPostMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPost.t.Fatal("No results are set for the PostCRUDMock.AddPost")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddPost.funcAddPost != nil {
		return mmAddPost.funcAddPost(ctx, title, content, authorID, commentsAllowed)
	}
	mmAddPost.t.Fatalf("Unexpected call to PostCRUDMock.AddPost. %v %v %v %v %v", ctx, title, content, authorID, commentsAllowed)
	return
}

// AddPostAfterCounter returns a count of finished PostCRUDMock.AddPost invocations
func (mmAddPost *PostCRUDMock) AddPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPost.afterAddPostCounter)
}

// AddPostBeforeCounter returns a count of PostCRUDMock.AddPost invocations
func (mmAddPost *PostCRUDMock) AddPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPost.beforeAddPostCounter)
}

// Calls returns a list of arguments used in each call to PostCRUDMock.AddPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPost *mPostCRUDMockAddPost) Calls() []*PostCRUDMockAddPostParams {
	mmAddPost.mutex.RLock()

	argCopy := make([]*PostCRUDMockAddPostParams, len(mmAddPost.callArgs))
	copy(argCopy, mmAddPost.callArgs)

	mmAddPost.mutex.RUnlock()

	return argCopy
}

// MinimockAddPostDone returns true if the count of the AddPost invocations corresponds
// the number of defined expectations
func (m *PostCRUDMock) MinimockAddPostDone() bool {
	if m.AddPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPostMock.invocationsDone()
}

// MinimockAddPostInspect logs each unmet expectation
func (m *PostCRUDMock) MinimockAddPostInspect() {
	for _, e := range m.AddPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostCRUDMock.AddPost with params: %#v", *e.params)
		}
	}

	afterAddPostCounter := mm_atomic.LoadUint64(&m.afterAddPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPostMock.defaultExpectation != nil && afterAddPostCounter < 1 {
		if m.AddPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostCRUDMock.AddPost")
		} else {
			m.t.Errorf("Expected call to PostCRUDMock.AddPost with params: %#v", *m.AddPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPost != nil && afterAddPostCounter < 1 {
		m.t.Error("Expected call to PostCRUDMock.AddPost")
	}

	if !m.AddPostMock.invocationsDone() && afterAddPostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostCRUDMock.AddPost but found %d calls",
			mm_atomic.LoadUint64(&m.AddPostMock.expectedInvocations), afterAddPostCounter)
	}
}

type mPostCRUDMockChangeCommentsAllowed struct {
	optional           bool
	mock               *PostCRUDMock
	defaultExpectation *PostCRUDMockChangeCommentsAllowedExpectation
	expectations       []*PostCRUDMockChangeCommentsAllowedExpectation

	callArgs []*PostCRUDMockChangeCommentsAllowedParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PostCRUDMockChangeCommentsAllowedExpectation specifies expectation struct of the PostCRUD.ChangeCommentsAllowed
type PostCRUDMockChangeCommentsAllowedExpectation struct {
	mock      *PostCRUDMock
	params    *PostCRUDMockChangeCommentsAllowedParams
	paramPtrs *PostCRUDMockChangeCommentsAllowedParamPtrs
	results   *PostCRUDMockChangeCommentsAllowedResults
	Counter   uint64
}

// PostCRUDMockChangeCommentsAllowedParams contains parameters of the PostCRUD.ChangeCommentsAllowed
type PostCRUDMockChangeCommentsAllowedParams struct {
	ctx             context.Context
	postID          int
	commentsAllowed bool
}

// PostCRUDMockChangeCommentsAllowedParamPtrs contains pointers to parameters of the PostCRUD.ChangeCommentsAllowed
type PostCRUDMockChangeCommentsAllowedParamPtrs struct {
	ctx             *context.Context
	postID          *int
	commentsAllowed *bool
}

// PostCRUDMockChangeCommentsAllowedResults contains results of the PostCRUD.ChangeCommentsAllowed
type PostCRUDMockChangeCommentsAllowedResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Optional() *mPostCRUDMockChangeCommentsAllowed {
	mmChangeCommentsAllowed.optional = true
	return mmChangeCommentsAllowed
}

// Expect sets up expected params for PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Expect(ctx context.Context, postID int, commentsAllowed bool) *mPostCRUDMockChangeCommentsAllowed {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	if mmChangeCommentsAllowed.defaultExpectation == nil {
		mmChangeCommentsAllowed.defaultExpectation = &PostCRUDMockChangeCommentsAllowedExpectation{}
	}

	if mmChangeCommentsAllowed.defaultExpectation.paramPtrs != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by ExpectParams functions")
	}

	mmChangeCommentsAllowed.defaultExpectation.params = &PostCRUDMockChangeCommentsAllowedParams{ctx, postID, commentsAllowed}
	for _, e := range mmChangeCommentsAllowed.expectations {
		if minimock.Equal(e.params, mmChangeCommentsAllowed.defaultExpectation.params) {
			mmChangeCommentsAllowed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeCommentsAllowed.defaultExpectation.params)
		}
	}

	return mmChangeCommentsAllowed
}

// ExpectCtxParam1 sets up expected param ctx for PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) ExpectCtxParam1(ctx context.Context) *mPostCRUDMockChangeCommentsAllowed {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	if mmChangeCommentsAllowed.defaultExpectation == nil {
		mmChangeCommentsAllowed.defaultExpectation = &PostCRUDMockChangeCommentsAllowedExpectation{}
	}

	if mmChangeCommentsAllowed.defaultExpectation.params != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Expect")
	}

	if mmChangeCommentsAllowed.defaultExpectation.paramPtrs == nil {
		mmChangeCommentsAllowed.defaultExpectation.paramPtrs = &PostCRUDMockChangeCommentsAllowedParamPtrs{}
	}
	mmChangeCommentsAllowed.defaultExpectation.paramPtrs.ctx = &ctx

	return mmChangeCommentsAllowed
}

// ExpectPostIDParam2 sets up expected param postID for PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) ExpectPostIDParam2(postID int) *mPostCRUDMockChangeCommentsAllowed {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	if mmChangeCommentsAllowed.defaultExpectation == nil {
		mmChangeCommentsAllowed.defaultExpectation = &PostCRUDMockChangeCommentsAllowedExpectation{}
	}

	if mmChangeCommentsAllowed.defaultExpectation.params != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Expect")
	}

	if mmChangeCommentsAllowed.defaultExpectation.paramPtrs == nil {
		mmChangeCommentsAllowed.defaultExpectation.paramPtrs = &PostCRUDMockChangeCommentsAllowedParamPtrs{}
	}
	mmChangeCommentsAllowed.defaultExpectation.paramPtrs.postID = &postID

	return mmChangeCommentsAllowed
}

// ExpectCommentsAllowedParam3 sets up expected param commentsAllowed for PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) ExpectCommentsAllowedParam3(commentsAllowed bool) *mPostCRUDMockChangeCommentsAllowed {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	if mmChangeCommentsAllowed.defaultExpectation == nil {
		mmChangeCommentsAllowed.defaultExpectation = &PostCRUDMockChangeCommentsAllowedExpectation{}
	}

	if mmChangeCommentsAllowed.defaultExpectation.params != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Expect")
	}

	if mmChangeCommentsAllowed.defaultExpectation.paramPtrs == nil {
		mmChangeCommentsAllowed.defaultExpectation.paramPtrs = &PostCRUDMockChangeCommentsAllowedParamPtrs{}
	}
	mmChangeCommentsAllowed.defaultExpectation.paramPtrs.commentsAllowed = &commentsAllowed

	return mmChangeCommentsAllowed
}

// Inspect accepts an inspector function that has same arguments as the PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Inspect(f func(ctx context.Context, postID int, commentsAllowed bool)) *mPostCRUDMockChangeCommentsAllowed {
	if mmChangeCommentsAllowed.mock.inspectFuncChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("Inspect function is already set for PostCRUDMock.ChangeCommentsAllowed")
	}

	mmChangeCommentsAllowed.mock.inspectFuncChangeCommentsAllowed = f

	return mmChangeCommentsAllowed
}

// Return sets up results that will be returned by PostCRUD.ChangeCommentsAllowed
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Return(i1 int, err error) *PostCRUDMock {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	if mmChangeCommentsAllowed.defaultExpectation == nil {
		mmChangeCommentsAllowed.defaultExpectation = &PostCRUDMockChangeCommentsAllowedExpectation{mock: mmChangeCommentsAllowed.mock}
	}
	mmChangeCommentsAllowed.defaultExpectation.results = &PostCRUDMockChangeCommentsAllowedResults{i1, err}
	return mmChangeCommentsAllowed.mock
}

// Set uses given function f to mock the PostCRUD.ChangeCommentsAllowed method
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Set(f func(ctx context.Context, postID int, commentsAllowed bool) (i1 int, err error)) *PostCRUDMock {
	if mmChangeCommentsAllowed.defaultExpectation != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("Default expectation is already set for the PostCRUD.ChangeCommentsAllowed method")
	}

	if len(mmChangeCommentsAllowed.expectations) > 0 {
		mmChangeCommentsAllowed.mock.t.Fatalf("Some expectations are already set for the PostCRUD.ChangeCommentsAllowed method")
	}

	mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed = f
	return mmChangeCommentsAllowed.mock
}

// When sets expectation for the PostCRUD.ChangeCommentsAllowed which will trigger the result defined by the following
// Then helper
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) When(ctx context.Context, postID int, commentsAllowed bool) *PostCRUDMockChangeCommentsAllowedExpectation {
	if mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.mock.t.Fatalf("PostCRUDMock.ChangeCommentsAllowed mock is already set by Set")
	}

	expectation := &PostCRUDMockChangeCommentsAllowedExpectation{
		mock:   mmChangeCommentsAllowed.mock,
		params: &PostCRUDMockChangeCommentsAllowedParams{ctx, postID, commentsAllowed},
	}
	mmChangeCommentsAllowed.expectations = append(mmChangeCommentsAllowed.expectations, expectation)
	return expectation
}

// Then sets up PostCRUD.ChangeCommentsAllowed return parameters for the expectation previously defined by the When method
func (e *PostCRUDMockChangeCommentsAllowedExpectation) Then(i1 int, err error) *PostCRUDMock {
	e.results = &PostCRUDMockChangeCommentsAllowedResults{i1, err}
	return e.mock
}

// Times sets number of times PostCRUD.ChangeCommentsAllowed should be invoked
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Times(n uint64) *mPostCRUDMockChangeCommentsAllowed {
	if n == 0 {
		mmChangeCommentsAllowed.mock.t.Fatalf("Times of PostCRUDMock.ChangeCommentsAllowed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangeCommentsAllowed.expectedInvocations, n)
	return mmChangeCommentsAllowed
}

func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) invocationsDone() bool {
	if len(mmChangeCommentsAllowed.expectations) == 0 && mmChangeCommentsAllowed.defaultExpectation == nil && mmChangeCommentsAllowed.mock.funcChangeCommentsAllowed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangeCommentsAllowed.mock.afterChangeCommentsAllowedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangeCommentsAllowed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangeCommentsAllowed implements PostCRUD
func (mmChangeCommentsAllowed *PostCRUDMock) ChangeCommentsAllowed(ctx context.Context, postID int, commentsAllowed bool) (i1 int, err error) {
	mm_atomic.AddUint64(&mmChangeCommentsAllowed.beforeChangeCommentsAllowedCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeCommentsAllowed.afterChangeCommentsAllowedCounter, 1)

	if mmChangeCommentsAllowed.inspectFuncChangeCommentsAllowed != nil {
		mmChangeCommentsAllowed.inspectFuncChangeCommentsAllowed(ctx, postID, commentsAllowed)
	}

	mm_params := PostCRUDMockChangeCommentsAllowedParams{ctx, postID, commentsAllowed}

	// Record call args
	mmChangeCommentsAllowed.ChangeCommentsAllowedMock.mutex.Lock()
	mmChangeCommentsAllowed.ChangeCommentsAllowedMock.callArgs = append(mmChangeCommentsAllowed.ChangeCommentsAllowedMock.callArgs, &mm_params)
	mmChangeCommentsAllowed.ChangeCommentsAllowedMock.mutex.Unlock()

	for _, e := range mmChangeCommentsAllowed.ChangeCommentsAllowedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmChangeCommentsAllowed.ChangeCommentsAllowedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeCommentsAllowed.ChangeCommentsAllowedMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeCommentsAllowed.ChangeCommentsAllowedMock.defaultExpectation.params
		mm_want_ptrs := mmChangeCommentsAllowed.ChangeCommentsAllowedMock.defaultExpectation.paramPtrs

		mm_got := PostCRUDMockChangeCommentsAllowedParams{ctx, postID, commentsAllowed}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangeCommentsAllowed.t.Errorf("PostCRUDMock.ChangeCommentsAllowed got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmChangeCommentsAllowed.t.Errorf("PostCRUDMock.ChangeCommentsAllowed got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.commentsAllowed != nil && !minimock.Equal(*mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed) {
				mmChangeCommentsAllowed.t.Errorf("PostCRUDMock.ChangeCommentsAllowed got unexpected parameter commentsAllowed, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed, minimock.Diff(*mm_want_ptrs.commentsAllowed, mm_got.commentsAllowed))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeCommentsAllowed.t.Errorf("PostCRUDMock.ChangeCommentsAllowed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeCommentsAllowed.ChangeCommentsAllowedMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeCommentsAllowed.t.Fatal("No results are set for the PostCRUDMock.ChangeCommentsAllowed")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmChangeCommentsAllowed.funcChangeCommentsAllowed != nil {
		return mmChangeCommentsAllowed.funcChangeCommentsAllowed(ctx, postID, commentsAllowed)
	}
	mmChangeCommentsAllowed.t.Fatalf("Unexpected call to PostCRUDMock.ChangeCommentsAllowed. %v %v %v", ctx, postID, commentsAllowed)
	return
}

// ChangeCommentsAllowedAfterCounter returns a count of finished PostCRUDMock.ChangeCommentsAllowed invocations
func (mmChangeCommentsAllowed *PostCRUDMock) ChangeCommentsAllowedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeCommentsAllowed.afterChangeCommentsAllowedCounter)
}

// ChangeCommentsAllowedBeforeCounter returns a count of PostCRUDMock.ChangeCommentsAllowed invocations
func (mmChangeCommentsAllowed *PostCRUDMock) ChangeCommentsAllowedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeCommentsAllowed.beforeChangeCommentsAllowedCounter)
}

// Calls returns a list of arguments used in each call to PostCRUDMock.ChangeCommentsAllowed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeCommentsAllowed *mPostCRUDMockChangeCommentsAllowed) Calls() []*PostCRUDMockChangeCommentsAllowedParams {
	mmChangeCommentsAllowed.mutex.RLock()

	argCopy := make([]*PostCRUDMockChangeCommentsAllowedParams, len(mmChangeCommentsAllowed.callArgs))
	copy(argCopy, mmChangeCommentsAllowed.callArgs)

	mmChangeCommentsAllowed.mutex.RUnlock()

	return argCopy
}

// MinimockChangeCommentsAllowedDone returns true if the count of the ChangeCommentsAllowed invocations corresponds
// the number of defined expectations
func (m *PostCRUDMock) MinimockChangeCommentsAllowedDone() bool {
	if m.ChangeCommentsAllowedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeCommentsAllowedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeCommentsAllowedMock.invocationsDone()
}

// MinimockChangeCommentsAllowedInspect logs each unmet expectation
func (m *PostCRUDMock) MinimockChangeCommentsAllowedInspect() {
	for _, e := range m.ChangeCommentsAllowedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostCRUDMock.ChangeCommentsAllowed with params: %#v", *e.params)
		}
	}

	afterChangeCommentsAllowedCounter := mm_atomic.LoadUint64(&m.afterChangeCommentsAllowedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeCommentsAllowedMock.defaultExpectation != nil && afterChangeCommentsAllowedCounter < 1 {
		if m.ChangeCommentsAllowedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostCRUDMock.ChangeCommentsAllowed")
		} else {
			m.t.Errorf("Expected call to PostCRUDMock.ChangeCommentsAllowed with params: %#v", *m.ChangeCommentsAllowedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeCommentsAllowed != nil && afterChangeCommentsAllowedCounter < 1 {
		m.t.Error("Expected call to PostCRUDMock.ChangeCommentsAllowed")
	}

	if !m.ChangeCommentsAllowedMock.invocationsDone() && afterChangeCommentsAllowedCounter > 0 {
		m.t.Errorf("Expected %d calls to PostCRUDMock.ChangeCommentsAllowed but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeCommentsAllowedMock.expectedInvocations), afterChangeCommentsAllowedCounter)
	}
}

type mPostCRUDMockDeletePost struct {
	optional           bool
	mock               *PostCRUDMock
	defaultExpectation *PostCRUDMockDeletePostExpectation
	expectations       []*PostCRUDMockDeletePostExpectation

	callArgs []*PostCRUDMockDeletePostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PostCRUDMockDeletePostExpectation specifies expectation struct of the PostCRUD.DeletePost
type PostCRUDMockDeletePostExpectation struct {
	mock      *PostCRUDMock
	params    *PostCRUDMockDeletePostParams
	paramPtrs *PostCRUDMockDeletePostParamPtrs
	results   *PostCRUDMockDeletePostResults
	Counter   uint64
}

// PostCRUDMockDeletePostParams contains parameters of the PostCRUD.DeletePost
type PostCRUDMockDeletePostParams struct {
	ctx    context.Context
	postID int
}

// PostCRUDMockDeletePostParamPtrs contains pointers to parameters of the PostCRUD.DeletePost
type PostCRUDMockDeletePostParamPtrs struct {
	ctx    *context.Context
	postID *int
}

// PostCRUDMockDeletePostResults contains results of the PostCRUD.DeletePost
type PostCRUDMockDeletePostResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePost *mPostCRUDMockDeletePost) Optional() *mPostCRUDMockDeletePost {
	mmDeletePost.optional = true
	return mmDeletePost
}

// Expect sets up expected params for PostCRUD.DeletePost
func (mmDeletePost *mPostCRUDMockDeletePost) Expect(ctx context.Context, postID int) *mPostCRUDMockDeletePost {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &PostCRUDMockDeletePostExpectation{}
	}

	if mmDeletePost.defaultExpectation.paramPtrs != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by ExpectParams functions")
	}

	mmDeletePost.defaultExpectation.params = &PostCRUDMockDeletePostParams{ctx, postID}
	for _, e := range mmDeletePost.expectations {
		if minimock.Equal(e.params, mmDeletePost.defaultExpectation.params) {
			mmDeletePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePost.defaultExpectation.params)
		}
	}

	return mmDeletePost
}

// ExpectCtxParam1 sets up expected param ctx for PostCRUD.DeletePost
func (mmDeletePost *mPostCRUDMockDeletePost) ExpectCtxParam1(ctx context.Context) *mPostCRUDMockDeletePost {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &PostCRUDMockDeletePostExpectation{}
	}

	if mmDeletePost.defaultExpectation.params != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Expect")
	}

	if mmDeletePost.defaultExpectation.paramPtrs == nil {
		mmDeletePost.defaultExpectation.paramPtrs = &PostCRUDMockDeletePostParamPtrs{}
	}
	mmDeletePost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeletePost
}

// ExpectPostIDParam2 sets up expected param postID for PostCRUD.DeletePost
func (mmDeletePost *mPostCRUDMockDeletePost) ExpectPostIDParam2(postID int) *mPostCRUDMockDeletePost {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &PostCRUDMockDeletePostExpectation{}
	}

	if mmDeletePost.defaultExpectation.params != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Expect")
	}

	if mmDeletePost.defaultExpectation.paramPtrs == nil {
		mmDeletePost.defaultExpectation.paramPtrs = &PostCRUDMockDeletePostParamPtrs{}
	}
	mmDeletePost.defaultExpectation.paramPtrs.postID = &postID

	return mmDeletePost
}

// Inspect accepts an inspector function that has same arguments as the PostCRUD.DeletePost
func (mmDeletePost *mPostCRUDMockDeletePost) Inspect(f func(ctx context.Context, postID int)) *mPostCRUDMockDeletePost {
	if mmDeletePost.mock.inspectFuncDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("Inspect function is already set for PostCRUDMock.DeletePost")
	}

	mmDeletePost.mock.inspectFuncDeletePost = f

	return mmDeletePost
}

// Return sets up results that will be returned by PostCRUD.DeletePost
func (mmDeletePost *mPostCRUDMockDeletePost) Return(i1 int, err error) *PostCRUDMock {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &PostCRUDMockDeletePostExpectation{mock: mmDeletePost.mock}
	}
	mmDeletePost.defaultExpectation.results = &PostCRUDMockDeletePostResults{i1, err}
	return mmDeletePost.mock
}

// Set uses given function f to mock the PostCRUD.DeletePost method
func (mmDeletePost *mPostCRUDMockDeletePost) Set(f func(ctx context.Context, postID int) (i1 int, err error)) *PostCRUDMock {
	if mmDeletePost.defaultExpectation != nil {
		mmDeletePost.mock.t.Fatalf("Default expectation is already set for the PostCRUD.DeletePost method")
	}

	if len(mmDeletePost.expectations) > 0 {
		mmDeletePost.mock.t.Fatalf("Some expectations are already set for the PostCRUD.DeletePost method")
	}

	mmDeletePost.mock.funcDeletePost = f
	return mmDeletePost.mock
}

// When sets expectation for the PostCRUD.DeletePost which will trigger the result defined by the following
// Then helper
func (mmDeletePost *mPostCRUDMockDeletePost) When(ctx context.Context, postID int) *PostCRUDMockDeletePostExpectation {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("PostCRUDMock.DeletePost mock is already set by Set")
	}

	expectation := &PostCRUDMockDeletePostExpectation{
		mock:   mmDeletePost.mock,
		params: &PostCRUDMockDeletePostParams{ctx, postID},
	}
	mmDeletePost.expectations = append(mmDeletePost.expectations, expectation)
	return expectation
}

// Then sets up PostCRUD.DeletePost return parameters for the expectation previously defined by the When method
func (e *PostCRUDMockDeletePostExpectation) Then(i1 int, err error) *PostCRUDMock {
	e.results = &PostCRUDMockDeletePostResults{i1, err}
	return e.mock
}

// Times sets number of times PostCRUD.DeletePost should be invoked
func (mmDeletePost *mPostCRUDMockDeletePost) Times(n uint64) *mPostCRUDMockDeletePost {
	if n == 0 {
		mmDeletePost.mock.t.Fatalf("Times of PostCRUDMock.DeletePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePost.expectedInvocations, n)
	return mmDeletePost
}

func (mmDeletePost *mPostCRUDMockDeletePost) invocationsDone() bool {
	if len(mmDeletePost.expectations) == 0 && mmDeletePost.defaultExpectation == nil && mmDeletePost.mock.funcDeletePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePost.mock.afterDeletePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePost implements PostCRUD
func (mmDeletePost *PostCRUDMock) DeletePost(ctx context.Context, postID int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmDeletePost.beforeDeletePostCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePost.afterDeletePostCounter, 1)

	if mmDeletePost.inspectFuncDeletePost != nil {
		mmDeletePost.inspectFuncDeletePost(ctx, postID)
	}

	mm_params := PostCRUDMockDeletePostParams{ctx, postID}

	// Record call args
	mmDeletePost.DeletePostMock.mutex.Lock()
	mmDeletePost.DeletePostMock.callArgs = append(mmDeletePost.DeletePostMock.callArgs, &mm_params)
	mmDeletePost.DeletePostMock.mutex.Unlock()

	for _, e := range mmDeletePost.DeletePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeletePost.DeletePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePost.DeletePostMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePost.DeletePostMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePost.DeletePostMock.defaultExpectation.paramPtrs

		mm_got := PostCRUDMockDeletePostParams{ctx, postID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePost.t.Errorf("PostCRUDMock.DeletePost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmDeletePost.t.Errorf("PostCRUDMock.DeletePost got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePost.t.Errorf("PostCRUDMock.DeletePost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePost.DeletePostMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePost.t.Fatal("No results are set for the PostCRUDMock.DeletePost")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeletePost.funcDeletePost != nil {
		return mmDeletePost.funcDeletePost(ctx, postID)
	}
	mmDeletePost.t.Fatalf("Unexpected call to PostCRUDMock.DeletePost. %v %v", ctx, postID)
	return
}

// DeletePostAfterCounter returns a count of finished PostCRUDMock.DeletePost invocations
func (mmDeletePost *PostCRUDMock) DeletePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePost.afterDeletePostCounter)
}

// DeletePostBeforeCounter returns a count of PostCRUDMock.DeletePost invocations
func (mmDeletePost *PostCRUDMock) DeletePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePost.beforeDeletePostCounter)
}

// Calls returns a list of arguments used in each call to PostCRUDMock.DeletePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePost *mPostCRUDMockDeletePost) Calls() []*PostCRUDMockDeletePostParams {
	mmDeletePost.mutex.RLock()

	argCopy := make([]*PostCRUDMockDeletePostParams, len(mmDeletePost.callArgs))
	copy(argCopy, mmDeletePost.callArgs)

	mmDeletePost.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePostDone returns true if the count of the DeletePost invocations corresponds
// the number of defined expectations
func (m *PostCRUDMock) MinimockDeletePostDone() bool {
	if m.DeletePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePostMock.invocationsDone()
}

// MinimockDeletePostInspect logs each unmet expectation
func (m *PostCRUDMock) MinimockDeletePostInspect() {
	for _, e := range m.DeletePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostCRUDMock.DeletePost with params: %#v", *e.params)
		}
	}

	afterDeletePostCounter := mm_atomic.LoadUint64(&m.afterDeletePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePostMock.defaultExpectation != nil && afterDeletePostCounter < 1 {
		if m.DeletePostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostCRUDMock.DeletePost")
		} else {
			m.t.Errorf("Expected call to PostCRUDMock.DeletePost with params: %#v", *m.DeletePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePost != nil && afterDeletePostCounter < 1 {
		m.t.Error("Expected call to PostCRUDMock.DeletePost")
	}

	if !m.DeletePostMock.invocationsDone() && afterDeletePostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostCRUDMock.DeletePost but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePostMock.expectedInvocations), afterDeletePostCounter)
	}
}

type mPostCRUDMockGetPost struct {
	optional           bool
	mock               *PostCRUDMock
	defaultExpectation *PostCRUDMockGetPostExpectation
	expectations       []*PostCRUDMockGetPostExpectation

	callArgs []*PostCRUDMockGetPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PostCRUDMockGetPostExpectation specifies expectation struct of the PostCRUD.GetPost
type PostCRUDMockGetPostExpectation struct {
	mock      *PostCRUDMock
	params    *PostCRUDMockGetPostParams
	paramPtrs *PostCRUDMockGetPostParamPtrs
	results   *PostCRUDMockGetPostResults
	Counter   uint64
}

// PostCRUDMockGetPostParams contains parameters of the PostCRUD.GetPost
type PostCRUDMockGetPostParams struct {
	ctx    context.Context
	postID int
}

// PostCRUDMockGetPostParamPtrs contains pointers to parameters of the PostCRUD.GetPost
type PostCRUDMockGetPostParamPtrs struct {
	ctx    *context.Context
	postID *int
}

// PostCRUDMockGetPostResults contains results of the PostCRUD.GetPost
type PostCRUDMockGetPostResults struct {
	pp1 *model.Post
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPost *mPostCRUDMockGetPost) Optional() *mPostCRUDMockGetPost {
	mmGetPost.optional = true
	return mmGetPost
}

// Expect sets up expected params for PostCRUD.GetPost
func (mmGetPost *mPostCRUDMockGetPost) Expect(ctx context.Context, postID int) *mPostCRUDMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostCRUDMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.paramPtrs != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by ExpectParams functions")
	}

	mmGetPost.defaultExpectation.params = &PostCRUDMockGetPostParams{ctx, postID}
	for _, e := range mmGetPost.expectations {
		if minimock.Equal(e.params, mmGetPost.defaultExpectation.params) {
			mmGetPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPost.defaultExpectation.params)
		}
	}

	return mmGetPost
}

// ExpectCtxParam1 sets up expected param ctx for PostCRUD.GetPost
func (mmGetPost *mPostCRUDMockGetPost) ExpectCtxParam1(ctx context.Context) *mPostCRUDMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostCRUDMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &PostCRUDMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPost
}

// ExpectPostIDParam2 sets up expected param postID for PostCRUD.GetPost
func (mmGetPost *mPostCRUDMockGetPost) ExpectPostIDParam2(postID int) *mPostCRUDMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostCRUDMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &PostCRUDMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.postID = &postID

	return mmGetPost
}

// Inspect accepts an inspector function that has same arguments as the PostCRUD.GetPost
func (mmGetPost *mPostCRUDMockGetPost) Inspect(f func(ctx context.Context, postID int)) *mPostCRUDMockGetPost {
	if mmGetPost.mock.inspectFuncGetPost != nil {
		mmGetPost.mock.t.Fatalf("Inspect function is already set for PostCRUDMock.GetPost")
	}

	mmGetPost.mock.inspectFuncGetPost = f

	return mmGetPost
}

// Return sets up results that will be returned by PostCRUD.GetPost
func (mmGetPost *mPostCRUDMockGetPost) Return(pp1 *model.Post, err error) *PostCRUDMock {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostCRUDMockGetPostExpectation{mock: mmGetPost.mock}
	}
	mmGetPost.defaultExpectation.results = &PostCRUDMockGetPostResults{pp1, err}
	return mmGetPost.mock
}

// Set uses given function f to mock the PostCRUD.GetPost method
func (mmGetPost *mPostCRUDMockGetPost) Set(f func(ctx context.Context, postID int) (pp1 *model.Post, err error)) *PostCRUDMock {
	if mmGetPost.defaultExpectation != nil {
		mmGetPost.mock.t.Fatalf("Default expectation is already set for the PostCRUD.GetPost method")
	}

	if len(mmGetPost.expectations) > 0 {
		mmGetPost.mock.t.Fatalf("Some expectations are already set for the PostCRUD.GetPost method")
	}

	mmGetPost.mock.funcGetPost = f
	return mmGetPost.mock
}

// When sets expectation for the PostCRUD.GetPost which will trigger the result defined by the following
// Then helper
func (mmGetPost *mPostCRUDMockGetPost) When(ctx context.Context, postID int) *PostCRUDMockGetPostExpectation {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostCRUDMock.GetPost mock is already set by Set")
	}

	expectation := &PostCRUDMockGetPostExpectation{
		mock:   mmGetPost.mock,
		params: &PostCRUDMockGetPostParams{ctx, postID},
	}
	mmGetPost.expectations = append(mmGetPost.expectations, expectation)
	return expectation
}

// Then sets up PostCRUD.GetPost return parameters for the expectation previously defined by the When method
func (e *PostCRUDMockGetPostExpectation) Then(pp1 *model.Post, err error) *PostCRUDMock {
	e.results = &PostCRUDMockGetPostResults{pp1, err}
	return e.mock
}

// Times sets number of times PostCRUD.GetPost should be invoked
func (mmGetPost *mPostCRUDMockGetPost) Times(n uint64) *mPostCRUDMockGetPost {
	if n == 0 {
		mmGetPost.mock.t.Fatalf("Times of PostCRUDMock.GetPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPost.expectedInvocations, n)
	return mmGetPost
}

func (mmGetPost *mPostCRUDMockGetPost) invocationsDone() bool {
	if len(mmGetPost.expectations) == 0 && mmGetPost.defaultExpectation == nil && mmGetPost.mock.funcGetPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPost.mock.afterGetPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPost implements PostCRUD
func (mmGetPost *PostCRUDMock) GetPost(ctx context.Context, postID int) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPost.beforeGetPostCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPost.afterGetPostCounter, 1)

	if mmGetPost.inspectFuncGetPost != nil {
		mmGetPost.inspectFuncGetPost(ctx, postID)
	}

	mm_params := PostCRUDMockGetPostParams{ctx, postID}

	// Record call args
	mmGetPost.GetPostMock.mutex.Lock()
	mmGetPost.GetPostMock.callArgs = append(mmGetPost.GetPostMock.callArgs, &mm_params)
	mmGetPost.GetPostMock.mutex.Unlock()

	for _, e := range mmGetPost.GetPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPost.GetPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPost.GetPostMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPost.GetPostMock.defaultExpectation.params
		mm_want_ptrs := mmGetPost.GetPostMock.defaultExpectation.paramPtrs

		mm_got := PostCRUDMockGetPostParams{ctx, postID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPost.t.Errorf("PostCRUDMock.GetPost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetPost.t.Errorf("PostCRUDMock.GetPost got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPost.t.Errorf("PostCRUDMock.GetPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPost.GetPostMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPost.t.Fatal("No results are set for the PostCRUDMock.GetPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPost.funcGetPost != nil {
		return mmGetPost.funcGetPost(ctx, postID)
	}
	mmGetPost.t.Fatalf("Unexpected call to PostCRUDMock.GetPost. %v %v", ctx, postID)
	return
}

// GetPostAfterCounter returns a count of finished PostCRUDMock.GetPost invocations
func (mmGetPost *PostCRUDMock) GetPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.afterGetPostCounter)
}

// GetPostBeforeCounter returns a count of PostCRUDMock.GetPost invocations
func (mmGetPost *PostCRUDMock) GetPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.beforeGetPostCounter)
}

// Calls returns a list of arguments used in each call to PostCRUDMock.GetPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPost *mPostCRUDMockGetPost) Calls() []*PostCRUDMockGetPostParams {
	mmGetPost.mutex.RLock()

	argCopy := make([]*PostCRUDMockGetPostParams, len(mmGetPost.callArgs))
	copy(argCopy, mmGetPost.callArgs)

	mmGetPost.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostDone returns true if the count of the GetPost invocations corresponds
// the number of defined expectations
func (m *PostCRUDMock) MinimockGetPostDone() bool {
	if m.GetPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostMock.invocationsDone()
}

// MinimockGetPostInspect logs each unmet expectation
func (m *PostCRUDMock) MinimockGetPostInspect() {
	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostCRUDMock.GetPost with params: %#v", *e.params)
		}
	}

	afterGetPostCounter := mm_atomic.LoadUint64(&m.afterGetPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostMock.defaultExpectation != nil && afterGetPostCounter < 1 {
		if m.GetPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostCRUDMock.GetPost")
		} else {
			m.t.Errorf("Expected call to PostCRUDMock.GetPost with params: %#v", *m.GetPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPost != nil && afterGetPostCounter < 1 {
		m.t.Error("Expected call to PostCRUDMock.GetPost")
	}

	if !m.GetPostMock.invocationsDone() && afterGetPostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostCRUDMock.GetPost but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostMock.expectedInvocations), afterGetPostCounter)
	}
}

type mPostCRUDMockGetPosts struct {
	optional           bool
	mock               *PostCRUDMock
	defaultExpectation *PostCRUDMockGetPostsExpectation
	expectations       []*PostCRUDMockGetPostsExpectation

	callArgs []*PostCRUDMockGetPostsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PostCRUDMockGetPostsExpectation specifies expectation struct of the PostCRUD.GetPosts
type PostCRUDMockGetPostsExpectation struct {
	mock      *PostCRUDMock
	params    *PostCRUDMockGetPostsParams
	paramPtrs *PostCRUDMockGetPostsParamPtrs
	results   *PostCRUDMockGetPostsResults
	Counter   uint64
}

// PostCRUDMockGetPostsParams contains parameters of the PostCRUD.GetPosts
type PostCRUDMockGetPostsParams struct {
	ctx         context.Context
	page        int
	itemsByPage int
}

// PostCRUDMockGetPostsParamPtrs contains pointers to parameters of the PostCRUD.GetPosts
type PostCRUDMockGetPostsParamPtrs struct {
	ctx         *context.Context
	page        *int
	itemsByPage *int
}

// PostCRUDMockGetPostsResults contains results of the PostCRUD.GetPosts
type PostCRUDMockGetPostsResults struct {
	ppa1 []*model.Post
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPosts *mPostCRUDMockGetPosts) Optional() *mPostCRUDMockGetPosts {
	mmGetPosts.optional = true
	return mmGetPosts
}

// Expect sets up expected params for PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) Expect(ctx context.Context, page int, itemsByPage int) *mPostCRUDMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &PostCRUDMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.paramPtrs != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by ExpectParams functions")
	}

	mmGetPosts.defaultExpectation.params = &PostCRUDMockGetPostsParams{ctx, page, itemsByPage}
	for _, e := range mmGetPosts.expectations {
		if minimock.Equal(e.params, mmGetPosts.defaultExpectation.params) {
			mmGetPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPosts.defaultExpectation.params)
		}
	}

	return mmGetPosts
}

// ExpectCtxParam1 sets up expected param ctx for PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) ExpectCtxParam1(ctx context.Context) *mPostCRUDMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &PostCRUDMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.params != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Expect")
	}

	if mmGetPosts.defaultExpectation.paramPtrs == nil {
		mmGetPosts.defaultExpectation.paramPtrs = &PostCRUDMockGetPostsParamPtrs{}
	}
	mmGetPosts.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPosts
}

// ExpectPageParam2 sets up expected param page for PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) ExpectPageParam2(page int) *mPostCRUDMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &PostCRUDMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.params != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Expect")
	}

	if mmGetPosts.defaultExpectation.paramPtrs == nil {
		mmGetPosts.defaultExpectation.paramPtrs = &PostCRUDMockGetPostsParamPtrs{}
	}
	mmGetPosts.defaultExpectation.paramPtrs.page = &page

	return mmGetPosts
}

// ExpectItemsByPageParam3 sets up expected param itemsByPage for PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) ExpectItemsByPageParam3(itemsByPage int) *mPostCRUDMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &PostCRUDMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.params != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Expect")
	}

	if mmGetPosts.defaultExpectation.paramPtrs == nil {
		mmGetPosts.defaultExpectation.paramPtrs = &PostCRUDMockGetPostsParamPtrs{}
	}
	mmGetPosts.defaultExpectation.paramPtrs.itemsByPage = &itemsByPage

	return mmGetPosts
}

// Inspect accepts an inspector function that has same arguments as the PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) Inspect(f func(ctx context.Context, page int, itemsByPage int)) *mPostCRUDMockGetPosts {
	if mmGetPosts.mock.inspectFuncGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("Inspect function is already set for PostCRUDMock.GetPosts")
	}

	mmGetPosts.mock.inspectFuncGetPosts = f

	return mmGetPosts
}

// Return sets up results that will be returned by PostCRUD.GetPosts
func (mmGetPosts *mPostCRUDMockGetPosts) Return(ppa1 []*model.Post, err error) *PostCRUDMock {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &PostCRUDMockGetPostsExpectation{mock: mmGetPosts.mock}
	}
	mmGetPosts.defaultExpectation.results = &PostCRUDMockGetPostsResults{ppa1, err}
	return mmGetPosts.mock
}

// Set uses given function f to mock the PostCRUD.GetPosts method
func (mmGetPosts *mPostCRUDMockGetPosts) Set(f func(ctx context.Context, page int, itemsByPage int) (ppa1 []*model.Post, err error)) *PostCRUDMock {
	if mmGetPosts.defaultExpectation != nil {
		mmGetPosts.mock.t.Fatalf("Default expectation is already set for the PostCRUD.GetPosts method")
	}

	if len(mmGetPosts.expectations) > 0 {
		mmGetPosts.mock.t.Fatalf("Some expectations are already set for the PostCRUD.GetPosts method")
	}

	mmGetPosts.mock.funcGetPosts = f
	return mmGetPosts.mock
}

// When sets expectation for the PostCRUD.GetPosts which will trigger the result defined by the following
// Then helper
func (mmGetPosts *mPostCRUDMockGetPosts) When(ctx context.Context, page int, itemsByPage int) *PostCRUDMockGetPostsExpectation {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("PostCRUDMock.GetPosts mock is already set by Set")
	}

	expectation := &PostCRUDMockGetPostsExpectation{
		mock:   mmGetPosts.mock,
		params: &PostCRUDMockGetPostsParams{ctx, page, itemsByPage},
	}
	mmGetPosts.expectations = append(mmGetPosts.expectations, expectation)
	return expectation
}

// Then sets up PostCRUD.GetPosts return parameters for the expectation previously defined by the When method
func (e *PostCRUDMockGetPostsExpectation) Then(ppa1 []*model.Post, err error) *PostCRUDMock {
	e.results = &PostCRUDMockGetPostsResults{ppa1, err}
	return e.mock
}

// Times sets number of times PostCRUD.GetPosts should be invoked
func (mmGetPosts *mPostCRUDMockGetPosts) Times(n uint64) *mPostCRUDMockGetPosts {
	if n == 0 {
		mmGetPosts.mock.t.Fatalf("Times of PostCRUDMock.GetPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPosts.expectedInvocations, n)
	return mmGetPosts
}

func (mmGetPosts *mPostCRUDMockGetPosts) invocationsDone() bool {
	if len(mmGetPosts.expectations) == 0 && mmGetPosts.defaultExpectation == nil && mmGetPosts.mock.funcGetPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPosts.mock.afterGetPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPosts implements PostCRUD
func (mmGetPosts *PostCRUDMock) GetPosts(ctx context.Context, page int, itemsByPage int) (ppa1 []*model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPosts.beforeGetPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosts.afterGetPostsCounter, 1)

	if mmGetPosts.inspectFuncGetPosts != nil {
		mmGetPosts.inspectFuncGetPosts(ctx, page, itemsByPage)
	}

	mm_params := PostCRUDMockGetPostsParams{ctx, page, itemsByPage}

	// Record call args
	mmGetPosts.GetPostsMock.mutex.Lock()
	mmGetPosts.GetPostsMock.callArgs = append(mmGetPosts.GetPostsMock.callArgs, &mm_params)
	mmGetPosts.GetPostsMock.mutex.Unlock()

	for _, e := range mmGetPosts.GetPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetPosts.GetPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosts.GetPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPosts.GetPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPosts.GetPostsMock.defaultExpectation.paramPtrs

		mm_got := PostCRUDMockGetPostsParams{ctx, page, itemsByPage}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPosts.t.Errorf("PostCRUDMock.GetPosts got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetPosts.t.Errorf("PostCRUDMock.GetPosts got unexpected parameter page, want: %#v, got: %#v%s\n", *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.itemsByPage != nil && !minimock.Equal(*mm_want_ptrs.itemsByPage, mm_got.itemsByPage) {
				mmGetPosts.t.Errorf("PostCRUDMock.GetPosts got unexpected parameter itemsByPage, want: %#v, got: %#v%s\n", *mm_want_ptrs.itemsByPage, mm_got.itemsByPage, minimock.Diff(*mm_want_ptrs.itemsByPage, mm_got.itemsByPage))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPosts.t.Errorf("PostCRUDMock.GetPosts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPosts.GetPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosts.t.Fatal("No results are set for the PostCRUDMock.GetPosts")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetPosts.funcGetPosts != nil {
		return mmGetPosts.funcGetPosts(ctx, page, itemsByPage)
	}
	mmGetPosts.t.Fatalf("Unexpected call to PostCRUDMock.GetPosts. %v %v %v", ctx, page, itemsByPage)
	return
}

// GetPostsAfterCounter returns a count of finished PostCRUDMock.GetPosts invocations
func (mmGetPosts *PostCRUDMock) GetPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.afterGetPostsCounter)
}

// GetPostsBeforeCounter returns a count of PostCRUDMock.GetPosts invocations
func (mmGetPosts *PostCRUDMock) GetPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.beforeGetPostsCounter)
}

// Calls returns a list of arguments used in each call to PostCRUDMock.GetPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPosts *mPostCRUDMockGetPosts) Calls() []*PostCRUDMockGetPostsParams {
	mmGetPosts.mutex.RLock()

	argCopy := make([]*PostCRUDMockGetPostsParams, len(mmGetPosts.callArgs))
	copy(argCopy, mmGetPosts.callArgs)

	mmGetPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostsDone returns true if the count of the GetPosts invocations corresponds
// the number of defined expectations
func (m *PostCRUDMock) MinimockGetPostsDone() bool {
	if m.GetPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostsMock.invocationsDone()
}

// MinimockGetPostsInspect logs each unmet expectation
func (m *PostCRUDMock) MinimockGetPostsInspect() {
	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostCRUDMock.GetPosts with params: %#v", *e.params)
		}
	}

	afterGetPostsCounter := mm_atomic.LoadUint64(&m.afterGetPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsMock.defaultExpectation != nil && afterGetPostsCounter < 1 {
		if m.GetPostsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostCRUDMock.GetPosts")
		} else {
			m.t.Errorf("Expected call to PostCRUDMock.GetPosts with params: %#v", *m.GetPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosts != nil && afterGetPostsCounter < 1 {
		m.t.Error("Expected call to PostCRUDMock.GetPosts")
	}

	if !m.GetPostsMock.invocationsDone() && afterGetPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to PostCRUDMock.GetPosts but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostsMock.expectedInvocations), afterGetPostsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostCRUDMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPostInspect()

			m.MinimockChangeCommentsAllowedInspect()

			m.MinimockDeletePostInspect()

			m.MinimockGetPostInspect()

			m.MinimockGetPostsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostCRUDMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostCRUDMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPostDone() &&
		m.MinimockChangeCommentsAllowedDone() &&
		m.MinimockDeletePostDone() &&
		m.MinimockGetPostDone() &&
		m.MinimockGetPostsDone()
}
