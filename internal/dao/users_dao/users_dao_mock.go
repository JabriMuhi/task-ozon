// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package users_dao

//go:generate minimock -i taskOzon/internal/dao/users_dao.UserCRUD -o users_dao_mock.go -n UserCRUDMock -p users_dao

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UserCRUDMock implements UserCRUD
type UserCRUDMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUser          func(ctx context.Context, username string, password string, email string) (i1 int, err error)
	inspectFuncAddUser   func(ctx context.Context, username string, password string, email string)
	afterAddUserCounter  uint64
	beforeAddUserCounter uint64
	AddUserMock          mUserCRUDMockAddUser

	funcDeleteUser          func(ctx context.Context, userID int) (i1 int, err error)
	inspectFuncDeleteUser   func(ctx context.Context, userID int)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserCRUDMockDeleteUser

	funcGetUser          func(ctx context.Context, userID int) (s1 string, err error)
	inspectFuncGetUser   func(ctx context.Context, userID int)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserCRUDMockGetUser
}

// NewUserCRUDMock returns a mock for UserCRUD
func NewUserCRUDMock(t minimock.Tester) *UserCRUDMock {
	m := &UserCRUDMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserMock = mUserCRUDMockAddUser{mock: m}
	m.AddUserMock.callArgs = []*UserCRUDMockAddUserParams{}

	m.DeleteUserMock = mUserCRUDMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserCRUDMockDeleteUserParams{}

	m.GetUserMock = mUserCRUDMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserCRUDMockGetUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCRUDMockAddUser struct {
	optional           bool
	mock               *UserCRUDMock
	defaultExpectation *UserCRUDMockAddUserExpectation
	expectations       []*UserCRUDMockAddUserExpectation

	callArgs []*UserCRUDMockAddUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCRUDMockAddUserExpectation specifies expectation struct of the UserCRUD.AddUser
type UserCRUDMockAddUserExpectation struct {
	mock      *UserCRUDMock
	params    *UserCRUDMockAddUserParams
	paramPtrs *UserCRUDMockAddUserParamPtrs
	results   *UserCRUDMockAddUserResults
	Counter   uint64
}

// UserCRUDMockAddUserParams contains parameters of the UserCRUD.AddUser
type UserCRUDMockAddUserParams struct {
	ctx      context.Context
	username string
	password string
	email    string
}

// UserCRUDMockAddUserParamPtrs contains pointers to parameters of the UserCRUD.AddUser
type UserCRUDMockAddUserParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
	email    *string
}

// UserCRUDMockAddUserResults contains results of the UserCRUD.AddUser
type UserCRUDMockAddUserResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUser *mUserCRUDMockAddUser) Optional() *mUserCRUDMockAddUser {
	mmAddUser.optional = true
	return mmAddUser
}

// Expect sets up expected params for UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) Expect(ctx context.Context, username string, password string, email string) *mUserCRUDMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.paramPtrs != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by ExpectParams functions")
	}

	mmAddUser.defaultExpectation.params = &UserCRUDMockAddUserParams{ctx, username, password, email}
	for _, e := range mmAddUser.expectations {
		if minimock.Equal(e.params, mmAddUser.defaultExpectation.params) {
			mmAddUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUser.defaultExpectation.params)
		}
	}

	return mmAddUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) ExpectCtxParam1(ctx context.Context) *mUserCRUDMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &UserCRUDMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddUser
}

// ExpectUsernameParam2 sets up expected param username for UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) ExpectUsernameParam2(username string) *mUserCRUDMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &UserCRUDMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.username = &username

	return mmAddUser
}

// ExpectPasswordParam3 sets up expected param password for UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) ExpectPasswordParam3(password string) *mUserCRUDMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &UserCRUDMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.password = &password

	return mmAddUser
}

// ExpectEmailParam4 sets up expected param email for UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) ExpectEmailParam4(email string) *mUserCRUDMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &UserCRUDMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.email = &email

	return mmAddUser
}

// Inspect accepts an inspector function that has same arguments as the UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) Inspect(f func(ctx context.Context, username string, password string, email string)) *mUserCRUDMockAddUser {
	if mmAddUser.mock.inspectFuncAddUser != nil {
		mmAddUser.mock.t.Fatalf("Inspect function is already set for UserCRUDMock.AddUser")
	}

	mmAddUser.mock.inspectFuncAddUser = f

	return mmAddUser
}

// Return sets up results that will be returned by UserCRUD.AddUser
func (mmAddUser *mUserCRUDMockAddUser) Return(i1 int, err error) *UserCRUDMock {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &UserCRUDMockAddUserExpectation{mock: mmAddUser.mock}
	}
	mmAddUser.defaultExpectation.results = &UserCRUDMockAddUserResults{i1, err}
	return mmAddUser.mock
}

// Set uses given function f to mock the UserCRUD.AddUser method
func (mmAddUser *mUserCRUDMockAddUser) Set(f func(ctx context.Context, username string, password string, email string) (i1 int, err error)) *UserCRUDMock {
	if mmAddUser.defaultExpectation != nil {
		mmAddUser.mock.t.Fatalf("Default expectation is already set for the UserCRUD.AddUser method")
	}

	if len(mmAddUser.expectations) > 0 {
		mmAddUser.mock.t.Fatalf("Some expectations are already set for the UserCRUD.AddUser method")
	}

	mmAddUser.mock.funcAddUser = f
	return mmAddUser.mock
}

// When sets expectation for the UserCRUD.AddUser which will trigger the result defined by the following
// Then helper
func (mmAddUser *mUserCRUDMockAddUser) When(ctx context.Context, username string, password string, email string) *UserCRUDMockAddUserExpectation {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("UserCRUDMock.AddUser mock is already set by Set")
	}

	expectation := &UserCRUDMockAddUserExpectation{
		mock:   mmAddUser.mock,
		params: &UserCRUDMockAddUserParams{ctx, username, password, email},
	}
	mmAddUser.expectations = append(mmAddUser.expectations, expectation)
	return expectation
}

// Then sets up UserCRUD.AddUser return parameters for the expectation previously defined by the When method
func (e *UserCRUDMockAddUserExpectation) Then(i1 int, err error) *UserCRUDMock {
	e.results = &UserCRUDMockAddUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserCRUD.AddUser should be invoked
func (mmAddUser *mUserCRUDMockAddUser) Times(n uint64) *mUserCRUDMockAddUser {
	if n == 0 {
		mmAddUser.mock.t.Fatalf("Times of UserCRUDMock.AddUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUser.expectedInvocations, n)
	return mmAddUser
}

func (mmAddUser *mUserCRUDMockAddUser) invocationsDone() bool {
	if len(mmAddUser.expectations) == 0 && mmAddUser.defaultExpectation == nil && mmAddUser.mock.funcAddUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUser.mock.afterAddUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUser implements UserCRUD
func (mmAddUser *UserCRUDMock) AddUser(ctx context.Context, username string, password string, email string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAddUser.beforeAddUserCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUser.afterAddUserCounter, 1)

	if mmAddUser.inspectFuncAddUser != nil {
		mmAddUser.inspectFuncAddUser(ctx, username, password, email)
	}

	mm_params := UserCRUDMockAddUserParams{ctx, username, password, email}

	// Record call args
	mmAddUser.AddUserMock.mutex.Lock()
	mmAddUser.AddUserMock.callArgs = append(mmAddUser.AddUserMock.callArgs, &mm_params)
	mmAddUser.AddUserMock.mutex.Unlock()

	for _, e := range mmAddUser.AddUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddUser.AddUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUser.AddUserMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUser.AddUserMock.defaultExpectation.params
		mm_want_ptrs := mmAddUser.AddUserMock.defaultExpectation.paramPtrs

		mm_got := UserCRUDMockAddUserParams{ctx, username, password, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUser.t.Errorf("UserCRUDMock.AddUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAddUser.t.Errorf("UserCRUDMock.AddUser got unexpected parameter username, want: %#v, got: %#v%s\n", *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmAddUser.t.Errorf("UserCRUDMock.AddUser got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmAddUser.t.Errorf("UserCRUDMock.AddUser got unexpected parameter email, want: %#v, got: %#v%s\n", *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUser.t.Errorf("UserCRUDMock.AddUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUser.AddUserMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUser.t.Fatal("No results are set for the UserCRUDMock.AddUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddUser.funcAddUser != nil {
		return mmAddUser.funcAddUser(ctx, username, password, email)
	}
	mmAddUser.t.Fatalf("Unexpected call to UserCRUDMock.AddUser. %v %v %v %v", ctx, username, password, email)
	return
}

// AddUserAfterCounter returns a count of finished UserCRUDMock.AddUser invocations
func (mmAddUser *UserCRUDMock) AddUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.afterAddUserCounter)
}

// AddUserBeforeCounter returns a count of UserCRUDMock.AddUser invocations
func (mmAddUser *UserCRUDMock) AddUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.beforeAddUserCounter)
}

// Calls returns a list of arguments used in each call to UserCRUDMock.AddUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUser *mUserCRUDMockAddUser) Calls() []*UserCRUDMockAddUserParams {
	mmAddUser.mutex.RLock()

	argCopy := make([]*UserCRUDMockAddUserParams, len(mmAddUser.callArgs))
	copy(argCopy, mmAddUser.callArgs)

	mmAddUser.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserDone returns true if the count of the AddUser invocations corresponds
// the number of defined expectations
func (m *UserCRUDMock) MinimockAddUserDone() bool {
	if m.AddUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserMock.invocationsDone()
}

// MinimockAddUserInspect logs each unmet expectation
func (m *UserCRUDMock) MinimockAddUserInspect() {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCRUDMock.AddUser with params: %#v", *e.params)
		}
	}

	afterAddUserCounter := mm_atomic.LoadUint64(&m.afterAddUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && afterAddUserCounter < 1 {
		if m.AddUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCRUDMock.AddUser")
		} else {
			m.t.Errorf("Expected call to UserCRUDMock.AddUser with params: %#v", *m.AddUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && afterAddUserCounter < 1 {
		m.t.Error("Expected call to UserCRUDMock.AddUser")
	}

	if !m.AddUserMock.invocationsDone() && afterAddUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCRUDMock.AddUser but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserMock.expectedInvocations), afterAddUserCounter)
	}
}

type mUserCRUDMockDeleteUser struct {
	optional           bool
	mock               *UserCRUDMock
	defaultExpectation *UserCRUDMockDeleteUserExpectation
	expectations       []*UserCRUDMockDeleteUserExpectation

	callArgs []*UserCRUDMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCRUDMockDeleteUserExpectation specifies expectation struct of the UserCRUD.DeleteUser
type UserCRUDMockDeleteUserExpectation struct {
	mock      *UserCRUDMock
	params    *UserCRUDMockDeleteUserParams
	paramPtrs *UserCRUDMockDeleteUserParamPtrs
	results   *UserCRUDMockDeleteUserResults
	Counter   uint64
}

// UserCRUDMockDeleteUserParams contains parameters of the UserCRUD.DeleteUser
type UserCRUDMockDeleteUserParams struct {
	ctx    context.Context
	userID int
}

// UserCRUDMockDeleteUserParamPtrs contains pointers to parameters of the UserCRUD.DeleteUser
type UserCRUDMockDeleteUserParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// UserCRUDMockDeleteUserResults contains results of the UserCRUD.DeleteUser
type UserCRUDMockDeleteUserResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserCRUDMockDeleteUser) Optional() *mUserCRUDMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserCRUD.DeleteUser
func (mmDeleteUser *mUserCRUDMockDeleteUser) Expect(ctx context.Context, userID int) *mUserCRUDMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCRUDMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserCRUDMockDeleteUserParams{ctx, userID}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCRUD.DeleteUser
func (mmDeleteUser *mUserCRUDMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserCRUDMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCRUDMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserCRUDMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteUser
}

// ExpectUserIDParam2 sets up expected param userID for UserCRUD.DeleteUser
func (mmDeleteUser *mUserCRUDMockDeleteUser) ExpectUserIDParam2(userID int) *mUserCRUDMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCRUDMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserCRUDMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserCRUD.DeleteUser
func (mmDeleteUser *mUserCRUDMockDeleteUser) Inspect(f func(ctx context.Context, userID int)) *mUserCRUDMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserCRUDMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserCRUD.DeleteUser
func (mmDeleteUser *mUserCRUDMockDeleteUser) Return(i1 int, err error) *UserCRUDMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCRUDMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserCRUDMockDeleteUserResults{i1, err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserCRUD.DeleteUser method
func (mmDeleteUser *mUserCRUDMockDeleteUser) Set(f func(ctx context.Context, userID int) (i1 int, err error)) *UserCRUDMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserCRUD.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserCRUD.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the UserCRUD.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserCRUDMockDeleteUser) When(ctx context.Context, userID int) *UserCRUDMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCRUDMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserCRUDMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &UserCRUDMockDeleteUserParams{ctx, userID},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserCRUD.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserCRUDMockDeleteUserExpectation) Then(i1 int, err error) *UserCRUDMock {
	e.results = &UserCRUDMockDeleteUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserCRUD.DeleteUser should be invoked
func (mmDeleteUser *mUserCRUDMockDeleteUser) Times(n uint64) *mUserCRUDMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserCRUDMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	return mmDeleteUser
}

func (mmDeleteUser *mUserCRUDMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements UserCRUD
func (mmDeleteUser *UserCRUDMock) DeleteUser(ctx context.Context, userID int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, userID)
	}

	mm_params := UserCRUDMockDeleteUserParams{ctx, userID}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserCRUDMockDeleteUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserCRUDMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteUser.t.Errorf("UserCRUDMock.DeleteUser got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserCRUDMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserCRUDMock.DeleteUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, userID)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserCRUDMock.DeleteUser. %v %v", ctx, userID)
	return
}

// DeleteUserAfterCounter returns a count of finished UserCRUDMock.DeleteUser invocations
func (mmDeleteUser *UserCRUDMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserCRUDMock.DeleteUser invocations
func (mmDeleteUser *UserCRUDMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserCRUDMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserCRUDMockDeleteUser) Calls() []*UserCRUDMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserCRUDMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserCRUDMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserCRUDMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCRUDMock.DeleteUser with params: %#v", *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCRUDMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to UserCRUDMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Error("Expected call to UserCRUDMock.DeleteUser")
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCRUDMock.DeleteUser but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
	}
}

type mUserCRUDMockGetUser struct {
	optional           bool
	mock               *UserCRUDMock
	defaultExpectation *UserCRUDMockGetUserExpectation
	expectations       []*UserCRUDMockGetUserExpectation

	callArgs []*UserCRUDMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCRUDMockGetUserExpectation specifies expectation struct of the UserCRUD.GetUser
type UserCRUDMockGetUserExpectation struct {
	mock      *UserCRUDMock
	params    *UserCRUDMockGetUserParams
	paramPtrs *UserCRUDMockGetUserParamPtrs
	results   *UserCRUDMockGetUserResults
	Counter   uint64
}

// UserCRUDMockGetUserParams contains parameters of the UserCRUD.GetUser
type UserCRUDMockGetUserParams struct {
	ctx    context.Context
	userID int
}

// UserCRUDMockGetUserParamPtrs contains pointers to parameters of the UserCRUD.GetUser
type UserCRUDMockGetUserParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// UserCRUDMockGetUserResults contains results of the UserCRUD.GetUser
type UserCRUDMockGetUserResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserCRUDMockGetUser) Optional() *mUserCRUDMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserCRUD.GetUser
func (mmGetUser *mUserCRUDMockGetUser) Expect(ctx context.Context, userID int) *mUserCRUDMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCRUDMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserCRUDMockGetUserParams{ctx, userID}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCRUD.GetUser
func (mmGetUser *mUserCRUDMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserCRUDMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCRUDMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCRUDMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetUser
}

// ExpectUserIDParam2 sets up expected param userID for UserCRUD.GetUser
func (mmGetUser *mUserCRUDMockGetUser) ExpectUserIDParam2(userID int) *mUserCRUDMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCRUDMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCRUDMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userID = &userID

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserCRUD.GetUser
func (mmGetUser *mUserCRUDMockGetUser) Inspect(f func(ctx context.Context, userID int)) *mUserCRUDMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserCRUDMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserCRUD.GetUser
func (mmGetUser *mUserCRUDMockGetUser) Return(s1 string, err error) *UserCRUDMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCRUDMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserCRUDMockGetUserResults{s1, err}
	return mmGetUser.mock
}

// Set uses given function f to mock the UserCRUD.GetUser method
func (mmGetUser *mUserCRUDMockGetUser) Set(f func(ctx context.Context, userID int) (s1 string, err error)) *UserCRUDMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserCRUD.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserCRUD.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the UserCRUD.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserCRUDMockGetUser) When(ctx context.Context, userID int) *UserCRUDMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCRUDMock.GetUser mock is already set by Set")
	}

	expectation := &UserCRUDMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &UserCRUDMockGetUserParams{ctx, userID},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserCRUD.GetUser return parameters for the expectation previously defined by the When method
func (e *UserCRUDMockGetUserExpectation) Then(s1 string, err error) *UserCRUDMock {
	e.results = &UserCRUDMockGetUserResults{s1, err}
	return e.mock
}

// Times sets number of times UserCRUD.GetUser should be invoked
func (mmGetUser *mUserCRUDMockGetUser) Times(n uint64) *mUserCRUDMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserCRUDMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	return mmGetUser
}

func (mmGetUser *mUserCRUDMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements UserCRUD
func (mmGetUser *UserCRUDMock) GetUser(ctx context.Context, userID int) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := UserCRUDMockGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserCRUDMockGetUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserCRUDMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUser.t.Errorf("UserCRUDMock.GetUser got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserCRUDMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserCRUDMock.GetUser")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserCRUDMock.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished UserCRUDMock.GetUser invocations
func (mmGetUser *UserCRUDMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserCRUDMock.GetUser invocations
func (mmGetUser *UserCRUDMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserCRUDMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserCRUDMockGetUser) Calls() []*UserCRUDMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserCRUDMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserCRUDMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserCRUDMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCRUDMock.GetUser with params: %#v", *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCRUDMock.GetUser")
		} else {
			m.t.Errorf("Expected call to UserCRUDMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Error("Expected call to UserCRUDMock.GetUser")
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCRUDMock.GetUser but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), afterGetUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCRUDMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCRUDMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCRUDMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone()
}
