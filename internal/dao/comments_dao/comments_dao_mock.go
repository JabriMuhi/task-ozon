// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package comments_dao

//go:generate minimock -i taskOzon/internal/dao/comments_dao.CommentCRUD -o comments_dao_mock.go -n CommentCRUDMock -p comments_dao

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"taskOzon/graph/model"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CommentCRUDMock implements CommentCRUD
type CommentCRUDMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddComment          func(ctx context.Context, text string, userID int, postID int) (i1 int, err error)
	inspectFuncAddComment   func(ctx context.Context, text string, userID int, postID int)
	afterAddCommentCounter  uint64
	beforeAddCommentCounter uint64
	AddCommentMock          mCommentCRUDMockAddComment

	funcAddReply          func(ctx context.Context, text string, userID int, parentCommentID int) (i1 int, err error)
	inspectFuncAddReply   func(ctx context.Context, text string, userID int, parentCommentID int)
	afterAddReplyCounter  uint64
	beforeAddReplyCounter uint64
	AddReplyMock          mCommentCRUDMockAddReply

	funcDeleteComment          func(ctx context.Context, commentID int) (i1 int, err error)
	inspectFuncDeleteComment   func(ctx context.Context, commentID int)
	afterDeleteCommentCounter  uint64
	beforeDeleteCommentCounter uint64
	DeleteCommentMock          mCommentCRUDMockDeleteComment

	funcGetChildrenComments          func(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error)
	inspectFuncGetChildrenComments   func(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int)
	afterGetChildrenCommentsCounter  uint64
	beforeGetChildrenCommentsCounter uint64
	GetChildrenCommentsMock          mCommentCRUDMockGetChildrenComments

	funcGetPostComments          func(ctx context.Context, postID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error)
	inspectFuncGetPostComments   func(ctx context.Context, postID int, startLevel int, lastLevel int, limit int)
	afterGetPostCommentsCounter  uint64
	beforeGetPostCommentsCounter uint64
	GetPostCommentsMock          mCommentCRUDMockGetPostComments
}

// NewCommentCRUDMock returns a mock for CommentCRUD
func NewCommentCRUDMock(t minimock.Tester) *CommentCRUDMock {
	m := &CommentCRUDMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCommentMock = mCommentCRUDMockAddComment{mock: m}
	m.AddCommentMock.callArgs = []*CommentCRUDMockAddCommentParams{}

	m.AddReplyMock = mCommentCRUDMockAddReply{mock: m}
	m.AddReplyMock.callArgs = []*CommentCRUDMockAddReplyParams{}

	m.DeleteCommentMock = mCommentCRUDMockDeleteComment{mock: m}
	m.DeleteCommentMock.callArgs = []*CommentCRUDMockDeleteCommentParams{}

	m.GetChildrenCommentsMock = mCommentCRUDMockGetChildrenComments{mock: m}
	m.GetChildrenCommentsMock.callArgs = []*CommentCRUDMockGetChildrenCommentsParams{}

	m.GetPostCommentsMock = mCommentCRUDMockGetPostComments{mock: m}
	m.GetPostCommentsMock.callArgs = []*CommentCRUDMockGetPostCommentsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommentCRUDMockAddComment struct {
	optional           bool
	mock               *CommentCRUDMock
	defaultExpectation *CommentCRUDMockAddCommentExpectation
	expectations       []*CommentCRUDMockAddCommentExpectation

	callArgs []*CommentCRUDMockAddCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentCRUDMockAddCommentExpectation specifies expectation struct of the CommentCRUD.AddComment
type CommentCRUDMockAddCommentExpectation struct {
	mock      *CommentCRUDMock
	params    *CommentCRUDMockAddCommentParams
	paramPtrs *CommentCRUDMockAddCommentParamPtrs
	results   *CommentCRUDMockAddCommentResults
	Counter   uint64
}

// CommentCRUDMockAddCommentParams contains parameters of the CommentCRUD.AddComment
type CommentCRUDMockAddCommentParams struct {
	ctx    context.Context
	text   string
	userID int
	postID int
}

// CommentCRUDMockAddCommentParamPtrs contains pointers to parameters of the CommentCRUD.AddComment
type CommentCRUDMockAddCommentParamPtrs struct {
	ctx    *context.Context
	text   *string
	userID *int
	postID *int
}

// CommentCRUDMockAddCommentResults contains results of the CommentCRUD.AddComment
type CommentCRUDMockAddCommentResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddComment *mCommentCRUDMockAddComment) Optional() *mCommentCRUDMockAddComment {
	mmAddComment.optional = true
	return mmAddComment
}

// Expect sets up expected params for CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) Expect(ctx context.Context, text string, userID int, postID int) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.paramPtrs != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by ExpectParams functions")
	}

	mmAddComment.defaultExpectation.params = &CommentCRUDMockAddCommentParams{ctx, text, userID, postID}
	for _, e := range mmAddComment.expectations {
		if minimock.Equal(e.params, mmAddComment.defaultExpectation.params) {
			mmAddComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddComment.defaultExpectation.params)
		}
	}

	return mmAddComment
}

// ExpectCtxParam1 sets up expected param ctx for CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) ExpectCtxParam1(ctx context.Context) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &CommentCRUDMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddComment
}

// ExpectTextParam2 sets up expected param text for CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) ExpectTextParam2(text string) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &CommentCRUDMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.text = &text

	return mmAddComment
}

// ExpectUserIDParam3 sets up expected param userID for CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) ExpectUserIDParam3(userID int) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &CommentCRUDMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.userID = &userID

	return mmAddComment
}

// ExpectPostIDParam4 sets up expected param postID for CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) ExpectPostIDParam4(postID int) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &CommentCRUDMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.postID = &postID

	return mmAddComment
}

// Inspect accepts an inspector function that has same arguments as the CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) Inspect(f func(ctx context.Context, text string, userID int, postID int)) *mCommentCRUDMockAddComment {
	if mmAddComment.mock.inspectFuncAddComment != nil {
		mmAddComment.mock.t.Fatalf("Inspect function is already set for CommentCRUDMock.AddComment")
	}

	mmAddComment.mock.inspectFuncAddComment = f

	return mmAddComment
}

// Return sets up results that will be returned by CommentCRUD.AddComment
func (mmAddComment *mCommentCRUDMockAddComment) Return(i1 int, err error) *CommentCRUDMock {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &CommentCRUDMockAddCommentExpectation{mock: mmAddComment.mock}
	}
	mmAddComment.defaultExpectation.results = &CommentCRUDMockAddCommentResults{i1, err}
	return mmAddComment.mock
}

// Set uses given function f to mock the CommentCRUD.AddComment method
func (mmAddComment *mCommentCRUDMockAddComment) Set(f func(ctx context.Context, text string, userID int, postID int) (i1 int, err error)) *CommentCRUDMock {
	if mmAddComment.defaultExpectation != nil {
		mmAddComment.mock.t.Fatalf("Default expectation is already set for the CommentCRUD.AddComment method")
	}

	if len(mmAddComment.expectations) > 0 {
		mmAddComment.mock.t.Fatalf("Some expectations are already set for the CommentCRUD.AddComment method")
	}

	mmAddComment.mock.funcAddComment = f
	return mmAddComment.mock
}

// When sets expectation for the CommentCRUD.AddComment which will trigger the result defined by the following
// Then helper
func (mmAddComment *mCommentCRUDMockAddComment) When(ctx context.Context, text string, userID int, postID int) *CommentCRUDMockAddCommentExpectation {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("CommentCRUDMock.AddComment mock is already set by Set")
	}

	expectation := &CommentCRUDMockAddCommentExpectation{
		mock:   mmAddComment.mock,
		params: &CommentCRUDMockAddCommentParams{ctx, text, userID, postID},
	}
	mmAddComment.expectations = append(mmAddComment.expectations, expectation)
	return expectation
}

// Then sets up CommentCRUD.AddComment return parameters for the expectation previously defined by the When method
func (e *CommentCRUDMockAddCommentExpectation) Then(i1 int, err error) *CommentCRUDMock {
	e.results = &CommentCRUDMockAddCommentResults{i1, err}
	return e.mock
}

// Times sets number of times CommentCRUD.AddComment should be invoked
func (mmAddComment *mCommentCRUDMockAddComment) Times(n uint64) *mCommentCRUDMockAddComment {
	if n == 0 {
		mmAddComment.mock.t.Fatalf("Times of CommentCRUDMock.AddComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddComment.expectedInvocations, n)
	return mmAddComment
}

func (mmAddComment *mCommentCRUDMockAddComment) invocationsDone() bool {
	if len(mmAddComment.expectations) == 0 && mmAddComment.defaultExpectation == nil && mmAddComment.mock.funcAddComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddComment.mock.afterAddCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddComment implements CommentCRUD
func (mmAddComment *CommentCRUDMock) AddComment(ctx context.Context, text string, userID int, postID int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAddComment.beforeAddCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmAddComment.afterAddCommentCounter, 1)

	if mmAddComment.inspectFuncAddComment != nil {
		mmAddComment.inspectFuncAddComment(ctx, text, userID, postID)
	}

	mm_params := CommentCRUDMockAddCommentParams{ctx, text, userID, postID}

	// Record call args
	mmAddComment.AddCommentMock.mutex.Lock()
	mmAddComment.AddCommentMock.callArgs = append(mmAddComment.AddCommentMock.callArgs, &mm_params)
	mmAddComment.AddCommentMock.mutex.Unlock()

	for _, e := range mmAddComment.AddCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddComment.AddCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddComment.AddCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmAddComment.AddCommentMock.defaultExpectation.params
		mm_want_ptrs := mmAddComment.AddCommentMock.defaultExpectation.paramPtrs

		mm_got := CommentCRUDMockAddCommentParams{ctx, text, userID, postID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddComment.t.Errorf("CommentCRUDMock.AddComment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmAddComment.t.Errorf("CommentCRUDMock.AddComment got unexpected parameter text, want: %#v, got: %#v%s\n", *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddComment.t.Errorf("CommentCRUDMock.AddComment got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmAddComment.t.Errorf("CommentCRUDMock.AddComment got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddComment.t.Errorf("CommentCRUDMock.AddComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddComment.AddCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmAddComment.t.Fatal("No results are set for the CommentCRUDMock.AddComment")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddComment.funcAddComment != nil {
		return mmAddComment.funcAddComment(ctx, text, userID, postID)
	}
	mmAddComment.t.Fatalf("Unexpected call to CommentCRUDMock.AddComment. %v %v %v %v", ctx, text, userID, postID)
	return
}

// AddCommentAfterCounter returns a count of finished CommentCRUDMock.AddComment invocations
func (mmAddComment *CommentCRUDMock) AddCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.afterAddCommentCounter)
}

// AddCommentBeforeCounter returns a count of CommentCRUDMock.AddComment invocations
func (mmAddComment *CommentCRUDMock) AddCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.beforeAddCommentCounter)
}

// Calls returns a list of arguments used in each call to CommentCRUDMock.AddComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddComment *mCommentCRUDMockAddComment) Calls() []*CommentCRUDMockAddCommentParams {
	mmAddComment.mutex.RLock()

	argCopy := make([]*CommentCRUDMockAddCommentParams, len(mmAddComment.callArgs))
	copy(argCopy, mmAddComment.callArgs)

	mmAddComment.mutex.RUnlock()

	return argCopy
}

// MinimockAddCommentDone returns true if the count of the AddComment invocations corresponds
// the number of defined expectations
func (m *CommentCRUDMock) MinimockAddCommentDone() bool {
	if m.AddCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCommentMock.invocationsDone()
}

// MinimockAddCommentInspect logs each unmet expectation
func (m *CommentCRUDMock) MinimockAddCommentInspect() {
	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentCRUDMock.AddComment with params: %#v", *e.params)
		}
	}

	afterAddCommentCounter := mm_atomic.LoadUint64(&m.afterAddCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommentMock.defaultExpectation != nil && afterAddCommentCounter < 1 {
		if m.AddCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentCRUDMock.AddComment")
		} else {
			m.t.Errorf("Expected call to CommentCRUDMock.AddComment with params: %#v", *m.AddCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComment != nil && afterAddCommentCounter < 1 {
		m.t.Error("Expected call to CommentCRUDMock.AddComment")
	}

	if !m.AddCommentMock.invocationsDone() && afterAddCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentCRUDMock.AddComment but found %d calls",
			mm_atomic.LoadUint64(&m.AddCommentMock.expectedInvocations), afterAddCommentCounter)
	}
}

type mCommentCRUDMockAddReply struct {
	optional           bool
	mock               *CommentCRUDMock
	defaultExpectation *CommentCRUDMockAddReplyExpectation
	expectations       []*CommentCRUDMockAddReplyExpectation

	callArgs []*CommentCRUDMockAddReplyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentCRUDMockAddReplyExpectation specifies expectation struct of the CommentCRUD.AddReply
type CommentCRUDMockAddReplyExpectation struct {
	mock      *CommentCRUDMock
	params    *CommentCRUDMockAddReplyParams
	paramPtrs *CommentCRUDMockAddReplyParamPtrs
	results   *CommentCRUDMockAddReplyResults
	Counter   uint64
}

// CommentCRUDMockAddReplyParams contains parameters of the CommentCRUD.AddReply
type CommentCRUDMockAddReplyParams struct {
	ctx             context.Context
	text            string
	userID          int
	parentCommentID int
}

// CommentCRUDMockAddReplyParamPtrs contains pointers to parameters of the CommentCRUD.AddReply
type CommentCRUDMockAddReplyParamPtrs struct {
	ctx             *context.Context
	text            *string
	userID          *int
	parentCommentID *int
}

// CommentCRUDMockAddReplyResults contains results of the CommentCRUD.AddReply
type CommentCRUDMockAddReplyResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReply *mCommentCRUDMockAddReply) Optional() *mCommentCRUDMockAddReply {
	mmAddReply.optional = true
	return mmAddReply
}

// Expect sets up expected params for CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) Expect(ctx context.Context, text string, userID int, parentCommentID int) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{}
	}

	if mmAddReply.defaultExpectation.paramPtrs != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by ExpectParams functions")
	}

	mmAddReply.defaultExpectation.params = &CommentCRUDMockAddReplyParams{ctx, text, userID, parentCommentID}
	for _, e := range mmAddReply.expectations {
		if minimock.Equal(e.params, mmAddReply.defaultExpectation.params) {
			mmAddReply.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReply.defaultExpectation.params)
		}
	}

	return mmAddReply
}

// ExpectCtxParam1 sets up expected param ctx for CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) ExpectCtxParam1(ctx context.Context) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{}
	}

	if mmAddReply.defaultExpectation.params != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Expect")
	}

	if mmAddReply.defaultExpectation.paramPtrs == nil {
		mmAddReply.defaultExpectation.paramPtrs = &CommentCRUDMockAddReplyParamPtrs{}
	}
	mmAddReply.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddReply
}

// ExpectTextParam2 sets up expected param text for CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) ExpectTextParam2(text string) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{}
	}

	if mmAddReply.defaultExpectation.params != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Expect")
	}

	if mmAddReply.defaultExpectation.paramPtrs == nil {
		mmAddReply.defaultExpectation.paramPtrs = &CommentCRUDMockAddReplyParamPtrs{}
	}
	mmAddReply.defaultExpectation.paramPtrs.text = &text

	return mmAddReply
}

// ExpectUserIDParam3 sets up expected param userID for CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) ExpectUserIDParam3(userID int) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{}
	}

	if mmAddReply.defaultExpectation.params != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Expect")
	}

	if mmAddReply.defaultExpectation.paramPtrs == nil {
		mmAddReply.defaultExpectation.paramPtrs = &CommentCRUDMockAddReplyParamPtrs{}
	}
	mmAddReply.defaultExpectation.paramPtrs.userID = &userID

	return mmAddReply
}

// ExpectParentCommentIDParam4 sets up expected param parentCommentID for CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) ExpectParentCommentIDParam4(parentCommentID int) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{}
	}

	if mmAddReply.defaultExpectation.params != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Expect")
	}

	if mmAddReply.defaultExpectation.paramPtrs == nil {
		mmAddReply.defaultExpectation.paramPtrs = &CommentCRUDMockAddReplyParamPtrs{}
	}
	mmAddReply.defaultExpectation.paramPtrs.parentCommentID = &parentCommentID

	return mmAddReply
}

// Inspect accepts an inspector function that has same arguments as the CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) Inspect(f func(ctx context.Context, text string, userID int, parentCommentID int)) *mCommentCRUDMockAddReply {
	if mmAddReply.mock.inspectFuncAddReply != nil {
		mmAddReply.mock.t.Fatalf("Inspect function is already set for CommentCRUDMock.AddReply")
	}

	mmAddReply.mock.inspectFuncAddReply = f

	return mmAddReply
}

// Return sets up results that will be returned by CommentCRUD.AddReply
func (mmAddReply *mCommentCRUDMockAddReply) Return(i1 int, err error) *CommentCRUDMock {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	if mmAddReply.defaultExpectation == nil {
		mmAddReply.defaultExpectation = &CommentCRUDMockAddReplyExpectation{mock: mmAddReply.mock}
	}
	mmAddReply.defaultExpectation.results = &CommentCRUDMockAddReplyResults{i1, err}
	return mmAddReply.mock
}

// Set uses given function f to mock the CommentCRUD.AddReply method
func (mmAddReply *mCommentCRUDMockAddReply) Set(f func(ctx context.Context, text string, userID int, parentCommentID int) (i1 int, err error)) *CommentCRUDMock {
	if mmAddReply.defaultExpectation != nil {
		mmAddReply.mock.t.Fatalf("Default expectation is already set for the CommentCRUD.AddReply method")
	}

	if len(mmAddReply.expectations) > 0 {
		mmAddReply.mock.t.Fatalf("Some expectations are already set for the CommentCRUD.AddReply method")
	}

	mmAddReply.mock.funcAddReply = f
	return mmAddReply.mock
}

// When sets expectation for the CommentCRUD.AddReply which will trigger the result defined by the following
// Then helper
func (mmAddReply *mCommentCRUDMockAddReply) When(ctx context.Context, text string, userID int, parentCommentID int) *CommentCRUDMockAddReplyExpectation {
	if mmAddReply.mock.funcAddReply != nil {
		mmAddReply.mock.t.Fatalf("CommentCRUDMock.AddReply mock is already set by Set")
	}

	expectation := &CommentCRUDMockAddReplyExpectation{
		mock:   mmAddReply.mock,
		params: &CommentCRUDMockAddReplyParams{ctx, text, userID, parentCommentID},
	}
	mmAddReply.expectations = append(mmAddReply.expectations, expectation)
	return expectation
}

// Then sets up CommentCRUD.AddReply return parameters for the expectation previously defined by the When method
func (e *CommentCRUDMockAddReplyExpectation) Then(i1 int, err error) *CommentCRUDMock {
	e.results = &CommentCRUDMockAddReplyResults{i1, err}
	return e.mock
}

// Times sets number of times CommentCRUD.AddReply should be invoked
func (mmAddReply *mCommentCRUDMockAddReply) Times(n uint64) *mCommentCRUDMockAddReply {
	if n == 0 {
		mmAddReply.mock.t.Fatalf("Times of CommentCRUDMock.AddReply mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReply.expectedInvocations, n)
	return mmAddReply
}

func (mmAddReply *mCommentCRUDMockAddReply) invocationsDone() bool {
	if len(mmAddReply.expectations) == 0 && mmAddReply.defaultExpectation == nil && mmAddReply.mock.funcAddReply == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReply.mock.afterAddReplyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReply.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReply implements CommentCRUD
func (mmAddReply *CommentCRUDMock) AddReply(ctx context.Context, text string, userID int, parentCommentID int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAddReply.beforeAddReplyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReply.afterAddReplyCounter, 1)

	if mmAddReply.inspectFuncAddReply != nil {
		mmAddReply.inspectFuncAddReply(ctx, text, userID, parentCommentID)
	}

	mm_params := CommentCRUDMockAddReplyParams{ctx, text, userID, parentCommentID}

	// Record call args
	mmAddReply.AddReplyMock.mutex.Lock()
	mmAddReply.AddReplyMock.callArgs = append(mmAddReply.AddReplyMock.callArgs, &mm_params)
	mmAddReply.AddReplyMock.mutex.Unlock()

	for _, e := range mmAddReply.AddReplyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddReply.AddReplyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReply.AddReplyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReply.AddReplyMock.defaultExpectation.params
		mm_want_ptrs := mmAddReply.AddReplyMock.defaultExpectation.paramPtrs

		mm_got := CommentCRUDMockAddReplyParams{ctx, text, userID, parentCommentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddReply.t.Errorf("CommentCRUDMock.AddReply got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmAddReply.t.Errorf("CommentCRUDMock.AddReply got unexpected parameter text, want: %#v, got: %#v%s\n", *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddReply.t.Errorf("CommentCRUDMock.AddReply got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.parentCommentID != nil && !minimock.Equal(*mm_want_ptrs.parentCommentID, mm_got.parentCommentID) {
				mmAddReply.t.Errorf("CommentCRUDMock.AddReply got unexpected parameter parentCommentID, want: %#v, got: %#v%s\n", *mm_want_ptrs.parentCommentID, mm_got.parentCommentID, minimock.Diff(*mm_want_ptrs.parentCommentID, mm_got.parentCommentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReply.t.Errorf("CommentCRUDMock.AddReply got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReply.AddReplyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReply.t.Fatal("No results are set for the CommentCRUDMock.AddReply")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddReply.funcAddReply != nil {
		return mmAddReply.funcAddReply(ctx, text, userID, parentCommentID)
	}
	mmAddReply.t.Fatalf("Unexpected call to CommentCRUDMock.AddReply. %v %v %v %v", ctx, text, userID, parentCommentID)
	return
}

// AddReplyAfterCounter returns a count of finished CommentCRUDMock.AddReply invocations
func (mmAddReply *CommentCRUDMock) AddReplyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReply.afterAddReplyCounter)
}

// AddReplyBeforeCounter returns a count of CommentCRUDMock.AddReply invocations
func (mmAddReply *CommentCRUDMock) AddReplyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReply.beforeAddReplyCounter)
}

// Calls returns a list of arguments used in each call to CommentCRUDMock.AddReply.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReply *mCommentCRUDMockAddReply) Calls() []*CommentCRUDMockAddReplyParams {
	mmAddReply.mutex.RLock()

	argCopy := make([]*CommentCRUDMockAddReplyParams, len(mmAddReply.callArgs))
	copy(argCopy, mmAddReply.callArgs)

	mmAddReply.mutex.RUnlock()

	return argCopy
}

// MinimockAddReplyDone returns true if the count of the AddReply invocations corresponds
// the number of defined expectations
func (m *CommentCRUDMock) MinimockAddReplyDone() bool {
	if m.AddReplyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReplyMock.invocationsDone()
}

// MinimockAddReplyInspect logs each unmet expectation
func (m *CommentCRUDMock) MinimockAddReplyInspect() {
	for _, e := range m.AddReplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentCRUDMock.AddReply with params: %#v", *e.params)
		}
	}

	afterAddReplyCounter := mm_atomic.LoadUint64(&m.afterAddReplyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReplyMock.defaultExpectation != nil && afterAddReplyCounter < 1 {
		if m.AddReplyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentCRUDMock.AddReply")
		} else {
			m.t.Errorf("Expected call to CommentCRUDMock.AddReply with params: %#v", *m.AddReplyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReply != nil && afterAddReplyCounter < 1 {
		m.t.Error("Expected call to CommentCRUDMock.AddReply")
	}

	if !m.AddReplyMock.invocationsDone() && afterAddReplyCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentCRUDMock.AddReply but found %d calls",
			mm_atomic.LoadUint64(&m.AddReplyMock.expectedInvocations), afterAddReplyCounter)
	}
}

type mCommentCRUDMockDeleteComment struct {
	optional           bool
	mock               *CommentCRUDMock
	defaultExpectation *CommentCRUDMockDeleteCommentExpectation
	expectations       []*CommentCRUDMockDeleteCommentExpectation

	callArgs []*CommentCRUDMockDeleteCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentCRUDMockDeleteCommentExpectation specifies expectation struct of the CommentCRUD.DeleteComment
type CommentCRUDMockDeleteCommentExpectation struct {
	mock      *CommentCRUDMock
	params    *CommentCRUDMockDeleteCommentParams
	paramPtrs *CommentCRUDMockDeleteCommentParamPtrs
	results   *CommentCRUDMockDeleteCommentResults
	Counter   uint64
}

// CommentCRUDMockDeleteCommentParams contains parameters of the CommentCRUD.DeleteComment
type CommentCRUDMockDeleteCommentParams struct {
	ctx       context.Context
	commentID int
}

// CommentCRUDMockDeleteCommentParamPtrs contains pointers to parameters of the CommentCRUD.DeleteComment
type CommentCRUDMockDeleteCommentParamPtrs struct {
	ctx       *context.Context
	commentID *int
}

// CommentCRUDMockDeleteCommentResults contains results of the CommentCRUD.DeleteComment
type CommentCRUDMockDeleteCommentResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Optional() *mCommentCRUDMockDeleteComment {
	mmDeleteComment.optional = true
	return mmDeleteComment
}

// Expect sets up expected params for CommentCRUD.DeleteComment
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Expect(ctx context.Context, commentID int) *mCommentCRUDMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &CommentCRUDMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.paramPtrs != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by ExpectParams functions")
	}

	mmDeleteComment.defaultExpectation.params = &CommentCRUDMockDeleteCommentParams{ctx, commentID}
	for _, e := range mmDeleteComment.expectations {
		if minimock.Equal(e.params, mmDeleteComment.defaultExpectation.params) {
			mmDeleteComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteComment.defaultExpectation.params)
		}
	}

	return mmDeleteComment
}

// ExpectCtxParam1 sets up expected param ctx for CommentCRUD.DeleteComment
func (mmDeleteComment *mCommentCRUDMockDeleteComment) ExpectCtxParam1(ctx context.Context) *mCommentCRUDMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &CommentCRUDMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.params != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Expect")
	}

	if mmDeleteComment.defaultExpectation.paramPtrs == nil {
		mmDeleteComment.defaultExpectation.paramPtrs = &CommentCRUDMockDeleteCommentParamPtrs{}
	}
	mmDeleteComment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteComment
}

// ExpectCommentIDParam2 sets up expected param commentID for CommentCRUD.DeleteComment
func (mmDeleteComment *mCommentCRUDMockDeleteComment) ExpectCommentIDParam2(commentID int) *mCommentCRUDMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &CommentCRUDMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.params != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Expect")
	}

	if mmDeleteComment.defaultExpectation.paramPtrs == nil {
		mmDeleteComment.defaultExpectation.paramPtrs = &CommentCRUDMockDeleteCommentParamPtrs{}
	}
	mmDeleteComment.defaultExpectation.paramPtrs.commentID = &commentID

	return mmDeleteComment
}

// Inspect accepts an inspector function that has same arguments as the CommentCRUD.DeleteComment
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Inspect(f func(ctx context.Context, commentID int)) *mCommentCRUDMockDeleteComment {
	if mmDeleteComment.mock.inspectFuncDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("Inspect function is already set for CommentCRUDMock.DeleteComment")
	}

	mmDeleteComment.mock.inspectFuncDeleteComment = f

	return mmDeleteComment
}

// Return sets up results that will be returned by CommentCRUD.DeleteComment
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Return(i1 int, err error) *CommentCRUDMock {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &CommentCRUDMockDeleteCommentExpectation{mock: mmDeleteComment.mock}
	}
	mmDeleteComment.defaultExpectation.results = &CommentCRUDMockDeleteCommentResults{i1, err}
	return mmDeleteComment.mock
}

// Set uses given function f to mock the CommentCRUD.DeleteComment method
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Set(f func(ctx context.Context, commentID int) (i1 int, err error)) *CommentCRUDMock {
	if mmDeleteComment.defaultExpectation != nil {
		mmDeleteComment.mock.t.Fatalf("Default expectation is already set for the CommentCRUD.DeleteComment method")
	}

	if len(mmDeleteComment.expectations) > 0 {
		mmDeleteComment.mock.t.Fatalf("Some expectations are already set for the CommentCRUD.DeleteComment method")
	}

	mmDeleteComment.mock.funcDeleteComment = f
	return mmDeleteComment.mock
}

// When sets expectation for the CommentCRUD.DeleteComment which will trigger the result defined by the following
// Then helper
func (mmDeleteComment *mCommentCRUDMockDeleteComment) When(ctx context.Context, commentID int) *CommentCRUDMockDeleteCommentExpectation {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("CommentCRUDMock.DeleteComment mock is already set by Set")
	}

	expectation := &CommentCRUDMockDeleteCommentExpectation{
		mock:   mmDeleteComment.mock,
		params: &CommentCRUDMockDeleteCommentParams{ctx, commentID},
	}
	mmDeleteComment.expectations = append(mmDeleteComment.expectations, expectation)
	return expectation
}

// Then sets up CommentCRUD.DeleteComment return parameters for the expectation previously defined by the When method
func (e *CommentCRUDMockDeleteCommentExpectation) Then(i1 int, err error) *CommentCRUDMock {
	e.results = &CommentCRUDMockDeleteCommentResults{i1, err}
	return e.mock
}

// Times sets number of times CommentCRUD.DeleteComment should be invoked
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Times(n uint64) *mCommentCRUDMockDeleteComment {
	if n == 0 {
		mmDeleteComment.mock.t.Fatalf("Times of CommentCRUDMock.DeleteComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteComment.expectedInvocations, n)
	return mmDeleteComment
}

func (mmDeleteComment *mCommentCRUDMockDeleteComment) invocationsDone() bool {
	if len(mmDeleteComment.expectations) == 0 && mmDeleteComment.defaultExpectation == nil && mmDeleteComment.mock.funcDeleteComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteComment.mock.afterDeleteCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteComment implements CommentCRUD
func (mmDeleteComment *CommentCRUDMock) DeleteComment(ctx context.Context, commentID int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmDeleteComment.beforeDeleteCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteComment.afterDeleteCommentCounter, 1)

	if mmDeleteComment.inspectFuncDeleteComment != nil {
		mmDeleteComment.inspectFuncDeleteComment(ctx, commentID)
	}

	mm_params := CommentCRUDMockDeleteCommentParams{ctx, commentID}

	// Record call args
	mmDeleteComment.DeleteCommentMock.mutex.Lock()
	mmDeleteComment.DeleteCommentMock.callArgs = append(mmDeleteComment.DeleteCommentMock.callArgs, &mm_params)
	mmDeleteComment.DeleteCommentMock.mutex.Unlock()

	for _, e := range mmDeleteComment.DeleteCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeleteComment.DeleteCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteComment.DeleteCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteComment.DeleteCommentMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteComment.DeleteCommentMock.defaultExpectation.paramPtrs

		mm_got := CommentCRUDMockDeleteCommentParams{ctx, commentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteComment.t.Errorf("CommentCRUDMock.DeleteComment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.commentID != nil && !minimock.Equal(*mm_want_ptrs.commentID, mm_got.commentID) {
				mmDeleteComment.t.Errorf("CommentCRUDMock.DeleteComment got unexpected parameter commentID, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentID, mm_got.commentID, minimock.Diff(*mm_want_ptrs.commentID, mm_got.commentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteComment.t.Errorf("CommentCRUDMock.DeleteComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteComment.DeleteCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteComment.t.Fatal("No results are set for the CommentCRUDMock.DeleteComment")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeleteComment.funcDeleteComment != nil {
		return mmDeleteComment.funcDeleteComment(ctx, commentID)
	}
	mmDeleteComment.t.Fatalf("Unexpected call to CommentCRUDMock.DeleteComment. %v %v", ctx, commentID)
	return
}

// DeleteCommentAfterCounter returns a count of finished CommentCRUDMock.DeleteComment invocations
func (mmDeleteComment *CommentCRUDMock) DeleteCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComment.afterDeleteCommentCounter)
}

// DeleteCommentBeforeCounter returns a count of CommentCRUDMock.DeleteComment invocations
func (mmDeleteComment *CommentCRUDMock) DeleteCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComment.beforeDeleteCommentCounter)
}

// Calls returns a list of arguments used in each call to CommentCRUDMock.DeleteComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteComment *mCommentCRUDMockDeleteComment) Calls() []*CommentCRUDMockDeleteCommentParams {
	mmDeleteComment.mutex.RLock()

	argCopy := make([]*CommentCRUDMockDeleteCommentParams, len(mmDeleteComment.callArgs))
	copy(argCopy, mmDeleteComment.callArgs)

	mmDeleteComment.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCommentDone returns true if the count of the DeleteComment invocations corresponds
// the number of defined expectations
func (m *CommentCRUDMock) MinimockDeleteCommentDone() bool {
	if m.DeleteCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCommentMock.invocationsDone()
}

// MinimockDeleteCommentInspect logs each unmet expectation
func (m *CommentCRUDMock) MinimockDeleteCommentInspect() {
	for _, e := range m.DeleteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentCRUDMock.DeleteComment with params: %#v", *e.params)
		}
	}

	afterDeleteCommentCounter := mm_atomic.LoadUint64(&m.afterDeleteCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCommentMock.defaultExpectation != nil && afterDeleteCommentCounter < 1 {
		if m.DeleteCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentCRUDMock.DeleteComment")
		} else {
			m.t.Errorf("Expected call to CommentCRUDMock.DeleteComment with params: %#v", *m.DeleteCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteComment != nil && afterDeleteCommentCounter < 1 {
		m.t.Error("Expected call to CommentCRUDMock.DeleteComment")
	}

	if !m.DeleteCommentMock.invocationsDone() && afterDeleteCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentCRUDMock.DeleteComment but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCommentMock.expectedInvocations), afterDeleteCommentCounter)
	}
}

type mCommentCRUDMockGetChildrenComments struct {
	optional           bool
	mock               *CommentCRUDMock
	defaultExpectation *CommentCRUDMockGetChildrenCommentsExpectation
	expectations       []*CommentCRUDMockGetChildrenCommentsExpectation

	callArgs []*CommentCRUDMockGetChildrenCommentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentCRUDMockGetChildrenCommentsExpectation specifies expectation struct of the CommentCRUD.GetChildrenComments
type CommentCRUDMockGetChildrenCommentsExpectation struct {
	mock      *CommentCRUDMock
	params    *CommentCRUDMockGetChildrenCommentsParams
	paramPtrs *CommentCRUDMockGetChildrenCommentsParamPtrs
	results   *CommentCRUDMockGetChildrenCommentsResults
	Counter   uint64
}

// CommentCRUDMockGetChildrenCommentsParams contains parameters of the CommentCRUD.GetChildrenComments
type CommentCRUDMockGetChildrenCommentsParams struct {
	ctx             context.Context
	parentCommentID int
	startLevel      int
	lastLevel       int
	limit           int
}

// CommentCRUDMockGetChildrenCommentsParamPtrs contains pointers to parameters of the CommentCRUD.GetChildrenComments
type CommentCRUDMockGetChildrenCommentsParamPtrs struct {
	ctx             *context.Context
	parentCommentID *int
	startLevel      *int
	lastLevel       *int
	limit           *int
}

// CommentCRUDMockGetChildrenCommentsResults contains results of the CommentCRUD.GetChildrenComments
type CommentCRUDMockGetChildrenCommentsResults struct {
	ca1 []model.Comment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Optional() *mCommentCRUDMockGetChildrenComments {
	mmGetChildrenComments.optional = true
	return mmGetChildrenComments
}

// Expect sets up expected params for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Expect(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by ExpectParams functions")
	}

	mmGetChildrenComments.defaultExpectation.params = &CommentCRUDMockGetChildrenCommentsParams{ctx, parentCommentID, startLevel, lastLevel, limit}
	for _, e := range mmGetChildrenComments.expectations {
		if minimock.Equal(e.params, mmGetChildrenComments.defaultExpectation.params) {
			mmGetChildrenComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChildrenComments.defaultExpectation.params)
		}
	}

	return mmGetChildrenComments
}

// ExpectCtxParam1 sets up expected param ctx for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) ExpectCtxParam1(ctx context.Context) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.params != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Expect")
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs == nil {
		mmGetChildrenComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetChildrenCommentsParamPtrs{}
	}
	mmGetChildrenComments.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetChildrenComments
}

// ExpectParentCommentIDParam2 sets up expected param parentCommentID for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) ExpectParentCommentIDParam2(parentCommentID int) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.params != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Expect")
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs == nil {
		mmGetChildrenComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetChildrenCommentsParamPtrs{}
	}
	mmGetChildrenComments.defaultExpectation.paramPtrs.parentCommentID = &parentCommentID

	return mmGetChildrenComments
}

// ExpectStartLevelParam3 sets up expected param startLevel for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) ExpectStartLevelParam3(startLevel int) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.params != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Expect")
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs == nil {
		mmGetChildrenComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetChildrenCommentsParamPtrs{}
	}
	mmGetChildrenComments.defaultExpectation.paramPtrs.startLevel = &startLevel

	return mmGetChildrenComments
}

// ExpectLastLevelParam4 sets up expected param lastLevel for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) ExpectLastLevelParam4(lastLevel int) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.params != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Expect")
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs == nil {
		mmGetChildrenComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetChildrenCommentsParamPtrs{}
	}
	mmGetChildrenComments.defaultExpectation.paramPtrs.lastLevel = &lastLevel

	return mmGetChildrenComments
}

// ExpectLimitParam5 sets up expected param limit for CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) ExpectLimitParam5(limit int) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{}
	}

	if mmGetChildrenComments.defaultExpectation.params != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Expect")
	}

	if mmGetChildrenComments.defaultExpectation.paramPtrs == nil {
		mmGetChildrenComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetChildrenCommentsParamPtrs{}
	}
	mmGetChildrenComments.defaultExpectation.paramPtrs.limit = &limit

	return mmGetChildrenComments
}

// Inspect accepts an inspector function that has same arguments as the CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Inspect(f func(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int)) *mCommentCRUDMockGetChildrenComments {
	if mmGetChildrenComments.mock.inspectFuncGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("Inspect function is already set for CommentCRUDMock.GetChildrenComments")
	}

	mmGetChildrenComments.mock.inspectFuncGetChildrenComments = f

	return mmGetChildrenComments
}

// Return sets up results that will be returned by CommentCRUD.GetChildrenComments
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Return(ca1 []model.Comment, err error) *CommentCRUDMock {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	if mmGetChildrenComments.defaultExpectation == nil {
		mmGetChildrenComments.defaultExpectation = &CommentCRUDMockGetChildrenCommentsExpectation{mock: mmGetChildrenComments.mock}
	}
	mmGetChildrenComments.defaultExpectation.results = &CommentCRUDMockGetChildrenCommentsResults{ca1, err}
	return mmGetChildrenComments.mock
}

// Set uses given function f to mock the CommentCRUD.GetChildrenComments method
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Set(f func(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error)) *CommentCRUDMock {
	if mmGetChildrenComments.defaultExpectation != nil {
		mmGetChildrenComments.mock.t.Fatalf("Default expectation is already set for the CommentCRUD.GetChildrenComments method")
	}

	if len(mmGetChildrenComments.expectations) > 0 {
		mmGetChildrenComments.mock.t.Fatalf("Some expectations are already set for the CommentCRUD.GetChildrenComments method")
	}

	mmGetChildrenComments.mock.funcGetChildrenComments = f
	return mmGetChildrenComments.mock
}

// When sets expectation for the CommentCRUD.GetChildrenComments which will trigger the result defined by the following
// Then helper
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) When(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int) *CommentCRUDMockGetChildrenCommentsExpectation {
	if mmGetChildrenComments.mock.funcGetChildrenComments != nil {
		mmGetChildrenComments.mock.t.Fatalf("CommentCRUDMock.GetChildrenComments mock is already set by Set")
	}

	expectation := &CommentCRUDMockGetChildrenCommentsExpectation{
		mock:   mmGetChildrenComments.mock,
		params: &CommentCRUDMockGetChildrenCommentsParams{ctx, parentCommentID, startLevel, lastLevel, limit},
	}
	mmGetChildrenComments.expectations = append(mmGetChildrenComments.expectations, expectation)
	return expectation
}

// Then sets up CommentCRUD.GetChildrenComments return parameters for the expectation previously defined by the When method
func (e *CommentCRUDMockGetChildrenCommentsExpectation) Then(ca1 []model.Comment, err error) *CommentCRUDMock {
	e.results = &CommentCRUDMockGetChildrenCommentsResults{ca1, err}
	return e.mock
}

// Times sets number of times CommentCRUD.GetChildrenComments should be invoked
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Times(n uint64) *mCommentCRUDMockGetChildrenComments {
	if n == 0 {
		mmGetChildrenComments.mock.t.Fatalf("Times of CommentCRUDMock.GetChildrenComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChildrenComments.expectedInvocations, n)
	return mmGetChildrenComments
}

func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) invocationsDone() bool {
	if len(mmGetChildrenComments.expectations) == 0 && mmGetChildrenComments.defaultExpectation == nil && mmGetChildrenComments.mock.funcGetChildrenComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChildrenComments.mock.afterGetChildrenCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChildrenComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChildrenComments implements CommentCRUD
func (mmGetChildrenComments *CommentCRUDMock) GetChildrenComments(ctx context.Context, parentCommentID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetChildrenComments.beforeGetChildrenCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChildrenComments.afterGetChildrenCommentsCounter, 1)

	if mmGetChildrenComments.inspectFuncGetChildrenComments != nil {
		mmGetChildrenComments.inspectFuncGetChildrenComments(ctx, parentCommentID, startLevel, lastLevel, limit)
	}

	mm_params := CommentCRUDMockGetChildrenCommentsParams{ctx, parentCommentID, startLevel, lastLevel, limit}

	// Record call args
	mmGetChildrenComments.GetChildrenCommentsMock.mutex.Lock()
	mmGetChildrenComments.GetChildrenCommentsMock.callArgs = append(mmGetChildrenComments.GetChildrenCommentsMock.callArgs, &mm_params)
	mmGetChildrenComments.GetChildrenCommentsMock.mutex.Unlock()

	for _, e := range mmGetChildrenComments.GetChildrenCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetChildrenComments.GetChildrenCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChildrenComments.GetChildrenCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChildrenComments.GetChildrenCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetChildrenComments.GetChildrenCommentsMock.defaultExpectation.paramPtrs

		mm_got := CommentCRUDMockGetChildrenCommentsParams{ctx, parentCommentID, startLevel, lastLevel, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentCommentID != nil && !minimock.Equal(*mm_want_ptrs.parentCommentID, mm_got.parentCommentID) {
				mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameter parentCommentID, want: %#v, got: %#v%s\n", *mm_want_ptrs.parentCommentID, mm_got.parentCommentID, minimock.Diff(*mm_want_ptrs.parentCommentID, mm_got.parentCommentID))
			}

			if mm_want_ptrs.startLevel != nil && !minimock.Equal(*mm_want_ptrs.startLevel, mm_got.startLevel) {
				mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameter startLevel, want: %#v, got: %#v%s\n", *mm_want_ptrs.startLevel, mm_got.startLevel, minimock.Diff(*mm_want_ptrs.startLevel, mm_got.startLevel))
			}

			if mm_want_ptrs.lastLevel != nil && !minimock.Equal(*mm_want_ptrs.lastLevel, mm_got.lastLevel) {
				mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameter lastLevel, want: %#v, got: %#v%s\n", *mm_want_ptrs.lastLevel, mm_got.lastLevel, minimock.Diff(*mm_want_ptrs.lastLevel, mm_got.lastLevel))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChildrenComments.t.Errorf("CommentCRUDMock.GetChildrenComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChildrenComments.GetChildrenCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChildrenComments.t.Fatal("No results are set for the CommentCRUDMock.GetChildrenComments")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetChildrenComments.funcGetChildrenComments != nil {
		return mmGetChildrenComments.funcGetChildrenComments(ctx, parentCommentID, startLevel, lastLevel, limit)
	}
	mmGetChildrenComments.t.Fatalf("Unexpected call to CommentCRUDMock.GetChildrenComments. %v %v %v %v %v", ctx, parentCommentID, startLevel, lastLevel, limit)
	return
}

// GetChildrenCommentsAfterCounter returns a count of finished CommentCRUDMock.GetChildrenComments invocations
func (mmGetChildrenComments *CommentCRUDMock) GetChildrenCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChildrenComments.afterGetChildrenCommentsCounter)
}

// GetChildrenCommentsBeforeCounter returns a count of CommentCRUDMock.GetChildrenComments invocations
func (mmGetChildrenComments *CommentCRUDMock) GetChildrenCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChildrenComments.beforeGetChildrenCommentsCounter)
}

// Calls returns a list of arguments used in each call to CommentCRUDMock.GetChildrenComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChildrenComments *mCommentCRUDMockGetChildrenComments) Calls() []*CommentCRUDMockGetChildrenCommentsParams {
	mmGetChildrenComments.mutex.RLock()

	argCopy := make([]*CommentCRUDMockGetChildrenCommentsParams, len(mmGetChildrenComments.callArgs))
	copy(argCopy, mmGetChildrenComments.callArgs)

	mmGetChildrenComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetChildrenCommentsDone returns true if the count of the GetChildrenComments invocations corresponds
// the number of defined expectations
func (m *CommentCRUDMock) MinimockGetChildrenCommentsDone() bool {
	if m.GetChildrenCommentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChildrenCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChildrenCommentsMock.invocationsDone()
}

// MinimockGetChildrenCommentsInspect logs each unmet expectation
func (m *CommentCRUDMock) MinimockGetChildrenCommentsInspect() {
	for _, e := range m.GetChildrenCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentCRUDMock.GetChildrenComments with params: %#v", *e.params)
		}
	}

	afterGetChildrenCommentsCounter := mm_atomic.LoadUint64(&m.afterGetChildrenCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChildrenCommentsMock.defaultExpectation != nil && afterGetChildrenCommentsCounter < 1 {
		if m.GetChildrenCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentCRUDMock.GetChildrenComments")
		} else {
			m.t.Errorf("Expected call to CommentCRUDMock.GetChildrenComments with params: %#v", *m.GetChildrenCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChildrenComments != nil && afterGetChildrenCommentsCounter < 1 {
		m.t.Error("Expected call to CommentCRUDMock.GetChildrenComments")
	}

	if !m.GetChildrenCommentsMock.invocationsDone() && afterGetChildrenCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentCRUDMock.GetChildrenComments but found %d calls",
			mm_atomic.LoadUint64(&m.GetChildrenCommentsMock.expectedInvocations), afterGetChildrenCommentsCounter)
	}
}

type mCommentCRUDMockGetPostComments struct {
	optional           bool
	mock               *CommentCRUDMock
	defaultExpectation *CommentCRUDMockGetPostCommentsExpectation
	expectations       []*CommentCRUDMockGetPostCommentsExpectation

	callArgs []*CommentCRUDMockGetPostCommentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentCRUDMockGetPostCommentsExpectation specifies expectation struct of the CommentCRUD.GetPostComments
type CommentCRUDMockGetPostCommentsExpectation struct {
	mock      *CommentCRUDMock
	params    *CommentCRUDMockGetPostCommentsParams
	paramPtrs *CommentCRUDMockGetPostCommentsParamPtrs
	results   *CommentCRUDMockGetPostCommentsResults
	Counter   uint64
}

// CommentCRUDMockGetPostCommentsParams contains parameters of the CommentCRUD.GetPostComments
type CommentCRUDMockGetPostCommentsParams struct {
	ctx        context.Context
	postID     int
	startLevel int
	lastLevel  int
	limit      int
}

// CommentCRUDMockGetPostCommentsParamPtrs contains pointers to parameters of the CommentCRUD.GetPostComments
type CommentCRUDMockGetPostCommentsParamPtrs struct {
	ctx        *context.Context
	postID     *int
	startLevel *int
	lastLevel  *int
	limit      *int
}

// CommentCRUDMockGetPostCommentsResults contains results of the CommentCRUD.GetPostComments
type CommentCRUDMockGetPostCommentsResults struct {
	ca1 []model.Comment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Optional() *mCommentCRUDMockGetPostComments {
	mmGetPostComments.optional = true
	return mmGetPostComments
}

// Expect sets up expected params for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Expect(ctx context.Context, postID int, startLevel int, lastLevel int, limit int) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.paramPtrs != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by ExpectParams functions")
	}

	mmGetPostComments.defaultExpectation.params = &CommentCRUDMockGetPostCommentsParams{ctx, postID, startLevel, lastLevel, limit}
	for _, e := range mmGetPostComments.expectations {
		if minimock.Equal(e.params, mmGetPostComments.defaultExpectation.params) {
			mmGetPostComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostComments.defaultExpectation.params)
		}
	}

	return mmGetPostComments
}

// ExpectCtxParam1 sets up expected param ctx for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) ExpectCtxParam1(ctx context.Context) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPostComments
}

// ExpectPostIDParam2 sets up expected param postID for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) ExpectPostIDParam2(postID int) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.postID = &postID

	return mmGetPostComments
}

// ExpectStartLevelParam3 sets up expected param startLevel for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) ExpectStartLevelParam3(startLevel int) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.startLevel = &startLevel

	return mmGetPostComments
}

// ExpectLastLevelParam4 sets up expected param lastLevel for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) ExpectLastLevelParam4(lastLevel int) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.lastLevel = &lastLevel

	return mmGetPostComments
}

// ExpectLimitParam5 sets up expected param limit for CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) ExpectLimitParam5(limit int) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentCRUDMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.limit = &limit

	return mmGetPostComments
}

// Inspect accepts an inspector function that has same arguments as the CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Inspect(f func(ctx context.Context, postID int, startLevel int, lastLevel int, limit int)) *mCommentCRUDMockGetPostComments {
	if mmGetPostComments.mock.inspectFuncGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("Inspect function is already set for CommentCRUDMock.GetPostComments")
	}

	mmGetPostComments.mock.inspectFuncGetPostComments = f

	return mmGetPostComments
}

// Return sets up results that will be returned by CommentCRUD.GetPostComments
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Return(ca1 []model.Comment, err error) *CommentCRUDMock {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentCRUDMockGetPostCommentsExpectation{mock: mmGetPostComments.mock}
	}
	mmGetPostComments.defaultExpectation.results = &CommentCRUDMockGetPostCommentsResults{ca1, err}
	return mmGetPostComments.mock
}

// Set uses given function f to mock the CommentCRUD.GetPostComments method
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Set(f func(ctx context.Context, postID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error)) *CommentCRUDMock {
	if mmGetPostComments.defaultExpectation != nil {
		mmGetPostComments.mock.t.Fatalf("Default expectation is already set for the CommentCRUD.GetPostComments method")
	}

	if len(mmGetPostComments.expectations) > 0 {
		mmGetPostComments.mock.t.Fatalf("Some expectations are already set for the CommentCRUD.GetPostComments method")
	}

	mmGetPostComments.mock.funcGetPostComments = f
	return mmGetPostComments.mock
}

// When sets expectation for the CommentCRUD.GetPostComments which will trigger the result defined by the following
// Then helper
func (mmGetPostComments *mCommentCRUDMockGetPostComments) When(ctx context.Context, postID int, startLevel int, lastLevel int, limit int) *CommentCRUDMockGetPostCommentsExpectation {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentCRUDMock.GetPostComments mock is already set by Set")
	}

	expectation := &CommentCRUDMockGetPostCommentsExpectation{
		mock:   mmGetPostComments.mock,
		params: &CommentCRUDMockGetPostCommentsParams{ctx, postID, startLevel, lastLevel, limit},
	}
	mmGetPostComments.expectations = append(mmGetPostComments.expectations, expectation)
	return expectation
}

// Then sets up CommentCRUD.GetPostComments return parameters for the expectation previously defined by the When method
func (e *CommentCRUDMockGetPostCommentsExpectation) Then(ca1 []model.Comment, err error) *CommentCRUDMock {
	e.results = &CommentCRUDMockGetPostCommentsResults{ca1, err}
	return e.mock
}

// Times sets number of times CommentCRUD.GetPostComments should be invoked
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Times(n uint64) *mCommentCRUDMockGetPostComments {
	if n == 0 {
		mmGetPostComments.mock.t.Fatalf("Times of CommentCRUDMock.GetPostComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostComments.expectedInvocations, n)
	return mmGetPostComments
}

func (mmGetPostComments *mCommentCRUDMockGetPostComments) invocationsDone() bool {
	if len(mmGetPostComments.expectations) == 0 && mmGetPostComments.defaultExpectation == nil && mmGetPostComments.mock.funcGetPostComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostComments.mock.afterGetPostCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostComments implements CommentCRUD
func (mmGetPostComments *CommentCRUDMock) GetPostComments(ctx context.Context, postID int, startLevel int, lastLevel int, limit int) (ca1 []model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetPostComments.beforeGetPostCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostComments.afterGetPostCommentsCounter, 1)

	if mmGetPostComments.inspectFuncGetPostComments != nil {
		mmGetPostComments.inspectFuncGetPostComments(ctx, postID, startLevel, lastLevel, limit)
	}

	mm_params := CommentCRUDMockGetPostCommentsParams{ctx, postID, startLevel, lastLevel, limit}

	// Record call args
	mmGetPostComments.GetPostCommentsMock.mutex.Lock()
	mmGetPostComments.GetPostCommentsMock.callArgs = append(mmGetPostComments.GetPostCommentsMock.callArgs, &mm_params)
	mmGetPostComments.GetPostCommentsMock.mutex.Unlock()

	for _, e := range mmGetPostComments.GetPostCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetPostComments.GetPostCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostComments.GetPostCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostComments.GetPostCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostComments.GetPostCommentsMock.defaultExpectation.paramPtrs

		mm_got := CommentCRUDMockGetPostCommentsParams{ctx, postID, startLevel, lastLevel, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.startLevel != nil && !minimock.Equal(*mm_want_ptrs.startLevel, mm_got.startLevel) {
				mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameter startLevel, want: %#v, got: %#v%s\n", *mm_want_ptrs.startLevel, mm_got.startLevel, minimock.Diff(*mm_want_ptrs.startLevel, mm_got.startLevel))
			}

			if mm_want_ptrs.lastLevel != nil && !minimock.Equal(*mm_want_ptrs.lastLevel, mm_got.lastLevel) {
				mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameter lastLevel, want: %#v, got: %#v%s\n", *mm_want_ptrs.lastLevel, mm_got.lastLevel, minimock.Diff(*mm_want_ptrs.lastLevel, mm_got.lastLevel))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostComments.t.Errorf("CommentCRUDMock.GetPostComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostComments.GetPostCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostComments.t.Fatal("No results are set for the CommentCRUDMock.GetPostComments")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetPostComments.funcGetPostComments != nil {
		return mmGetPostComments.funcGetPostComments(ctx, postID, startLevel, lastLevel, limit)
	}
	mmGetPostComments.t.Fatalf("Unexpected call to CommentCRUDMock.GetPostComments. %v %v %v %v %v", ctx, postID, startLevel, lastLevel, limit)
	return
}

// GetPostCommentsAfterCounter returns a count of finished CommentCRUDMock.GetPostComments invocations
func (mmGetPostComments *CommentCRUDMock) GetPostCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComments.afterGetPostCommentsCounter)
}

// GetPostCommentsBeforeCounter returns a count of CommentCRUDMock.GetPostComments invocations
func (mmGetPostComments *CommentCRUDMock) GetPostCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComments.beforeGetPostCommentsCounter)
}

// Calls returns a list of arguments used in each call to CommentCRUDMock.GetPostComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostComments *mCommentCRUDMockGetPostComments) Calls() []*CommentCRUDMockGetPostCommentsParams {
	mmGetPostComments.mutex.RLock()

	argCopy := make([]*CommentCRUDMockGetPostCommentsParams, len(mmGetPostComments.callArgs))
	copy(argCopy, mmGetPostComments.callArgs)

	mmGetPostComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostCommentsDone returns true if the count of the GetPostComments invocations corresponds
// the number of defined expectations
func (m *CommentCRUDMock) MinimockGetPostCommentsDone() bool {
	if m.GetPostCommentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostCommentsMock.invocationsDone()
}

// MinimockGetPostCommentsInspect logs each unmet expectation
func (m *CommentCRUDMock) MinimockGetPostCommentsInspect() {
	for _, e := range m.GetPostCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentCRUDMock.GetPostComments with params: %#v", *e.params)
		}
	}

	afterGetPostCommentsCounter := mm_atomic.LoadUint64(&m.afterGetPostCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostCommentsMock.defaultExpectation != nil && afterGetPostCommentsCounter < 1 {
		if m.GetPostCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentCRUDMock.GetPostComments")
		} else {
			m.t.Errorf("Expected call to CommentCRUDMock.GetPostComments with params: %#v", *m.GetPostCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostComments != nil && afterGetPostCommentsCounter < 1 {
		m.t.Error("Expected call to CommentCRUDMock.GetPostComments")
	}

	if !m.GetPostCommentsMock.invocationsDone() && afterGetPostCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentCRUDMock.GetPostComments but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostCommentsMock.expectedInvocations), afterGetPostCommentsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentCRUDMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCommentInspect()

			m.MinimockAddReplyInspect()

			m.MinimockDeleteCommentInspect()

			m.MinimockGetChildrenCommentsInspect()

			m.MinimockGetPostCommentsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentCRUDMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentCRUDMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCommentDone() &&
		m.MinimockAddReplyDone() &&
		m.MinimockDeleteCommentDone() &&
		m.MinimockGetChildrenCommentsDone() &&
		m.MinimockGetPostCommentsDone()
}
